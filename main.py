# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'main.ui'
#
# Created by: PyQt5 UI code generator 5.15.9
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QGraphicsScene, QApplication
import tempfile
import os
import cv2
from PIL import Image, ImageOps
import pandas as pd
import numpy as np
import mahotas as mt
from openpyxl import load_workbook
import matplotlib.pyplot as plt
from Gui_LogBrightness import LogBrightnessDialog
from Gui_Brightness import LinearBrightnessDialog
from Gui_Contrast import LinearContrastDialog
from Gui_Saturation import LinearSaturationDialog
from GUI_Contrast_Brightness import LinearContrastBrightnessDialog
from GUI_Cropping import CropsDialog
from GUI_Translasi import TranslasiDialog
from GUI_Rotasi import RotasiDialog
from GUI_Zoom import ZoomDialog
from GUI_Crop_Region import CropDialog
from skimage.morphology import skeletonize, thin
from skimage import data
from OperasiAritmatika import Ui_MainWindow as Ui_AritmatikaWindow
from tentang import Ui_MainWindow as tentang


class Ui_MainWindow(QtWidgets.QMainWindow):
    
    #metode __init__ 
    def __init__(self):
        super().__init__()
       
        self.imagePath = None
        self.image_pixmap = None  # Variable to store the selected image pixmap
        self.imagefile = None
        self.imageResult = None
       


    def setupUi(self, MainWindow):
        # Konfigurasi awal untuk MainWindow
        # Setup untuk self.actionOperasiAritmatika
        self.actionOperasiAritmatika = QtWidgets.QAction(MainWindow)
        self.actionOperasiAritmatika.setObjectName("actionOperasiAritmatika")
        self.actionOperasiAritmatika.triggered.connect(self.show_aritmatika_window)  # Hubungkan ke fungsi
        # Tambahan konfigurasi MainWindow lainnya

    def show_aritmatika_window(self):
        # Buat instance dari window aritmatika
        self.aritmatika_window = QtWidgets.QMainWindow()
        self.ui_aritmatika = Ui_AritmatikaWindow()
        self.ui_aritmatika.setupUi(self.aritmatika_window)
        self.aritmatika_window.show()

    def TentangFrame(self): 
            # Definisi fungsi frameArimatika yang merupakan metode dari suatu kelas. Fungsi ini mungkin digunakan untuk membuat dan menampilkan sebuah jendela Qt.
            self.window = QtWidgets.QMainWindow() # Membuat sebuah objek jendela utama dari Qt.
            self.ui = tentang() # Membuat sebuah objek dari kelas latihan.
            self.ui.setupUi(self.window) # Memanggil metode setupUi dari objek ui untuk menginisialisasi tampilan antarmuka.
            self.window.show()
      
    
    #metode show_image = menampilkan gambar 
    def show_image(self):
        self.imagefile.show()

    #metode openimage 
    def openImage(self):
        # Show file dialog to select an image file
        options = QFileDialog.Options()
        fileName, _ = QFileDialog.getOpenFileName(None, "Open Image", "", "Image Files (*.png *.jpg *.bmp *.jpeg)", options=options)
        
        if fileName:
            self.imagePath = fileName
            image_path = fileName
            img = Image.open(image_path)
            self.imagefile = img
            # img.show()

            # Load the image and display it in the QGraphicsView
            self.image_pixmap = QtGui.QPixmap(fileName)

            # Get the size of the QGraphicsView
            view_width = self.graphicsView.width()
            view_height = self.graphicsView.height()

            # Scale the pixmap to fit the QGraphicsView, preserving the aspect ratio
            scaled_pixmap = self.image_pixmap.scaled(view_width, view_height, QtCore.Qt.KeepAspectRatio)

            self.scene.clear()  # Clear any previous content in the scene
            self.scene.addPixmap(scaled_pixmap)
            # self.graphicsView.fitInView(self.scene.itemsBoundingRect(), QtCore.Qt.KeepAspectRatio)
            self.graphicsView.setSceneRect(self.scene.itemsBoundingRect())

    #fungsi untuk save As
    def saveAs(self):
        if hasattr(self, 'imageResult') and self.imageResult is not None:
            # Buka dialog untuk memilih lokasi dan memberi nama file
            options = QFileDialog.Options()
            fileName, _ = QFileDialog.getSaveFileName(None, "Save Image As", "", "PNG Files (*.png);;JPEG Files (*.jpg);;BMP Files (*.bmp)", options=options)
            
            if fileName:
                # Simpan gambar ke lokasi yang dipilih dengan nama file baru
                self.imageResult.save(fileName)
                print(f"Gambar disimpan di: {fileName}")
            else:
                print("Penyimpanan dibatalkan.")
        else:
            print("Tidak ada gambar untuk disimpan.")  

    def clear_images(self):
        """Menghapus gambar dari graphicsView (kotak 1) dan graphicsView_2 (kotak 2) serta membersihkan scene."""
        print("Button clicked, clearing images...")
        # Hapus konten dari kotak 1 (graphicsView)
        if hasattr(self, 'scene'):
            self.scene.clear()  # Clear scene if it exists
        else:
            self.graphicsView.scene().clear()  # Clear directly if no custom scene

        # Hapus konten dari kotak 2 (graphicsView_2)
        if hasattr(self, 'sceneOutput'):
            self.sceneOutput.clear()  # Clear scene if it exists
        else:
            self.graphicsView_2.scene().clear()  # Clear directly if no custom scene

        print("Images cleared from both kotak 1 and kotak 2.")




    def grayscale_average(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Implementasi metode Average
        def rgb_to_grayscale_average(image):
            return np.mean(image, axis=2).astype(np.uint8)

        # Mengonversi citra ke grayscale menggunakan metode Average
        grayscale_image = rgb_to_grayscale_average(image_np)

        # Menyimpan citra grayscale sebagai Image object
        output_image = Image.fromarray(grayscale_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar grayscale di kotak output (Kotak2)
        output_image.save("output_temp.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()  # Clear previous content in the output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def grayscale_lightness(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Implementasi metode Lightness
        def rgb_to_grayscale_lightness(image):
            max_rgb = np.max(image, axis=2)
            min_rgb = np.min(image, axis=2)
            return ((max_rgb + min_rgb) / 2).astype(np.uint8)

        # Mengonversi citra ke grayscale menggunakan metode Lightness
        grayscale_image = rgb_to_grayscale_lightness(image_np)

        # Menyimpan citra grayscale sebagai Image object
        output_image = Image.fromarray(grayscale_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar grayscale di kotak output (Kotak2)
        output_image.save("output_temp_lightness.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_lightness.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()  # Clear previous content in the output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def grayscale_luminance(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Implementasi metode Luminance
        def rgb_to_grayscale_luminance(image):
            return (0.2989 * image[:, :, 0] + 0.5870 * image[:, :, 1] + 0.1140 * image[:, :, 2]).astype(np.uint8)

        # Mengonversi citra ke grayscale menggunakan metode Luminance
        grayscale_image = rgb_to_grayscale_luminance(image_np)

        # Menyimpan citra grayscale sebagai Image object
        output_image = Image.fromarray(grayscale_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar grayscale di kotak output (Kotak2)
        output_image.save("output_temp_luminance.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_luminance.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def log_brightness_transformation(self):
    # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array menggunakan OpenCV
        image_np = np.array(image)
        
        # Mengubah gambar ke format grayscale menggunakan OpenCV
        image_gray = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Ambil nilai c dari slider
        c = self.sliderC.value()  # Ambil nilai c dari slider

        # Terapkan transformasi log brightness
        log_transformed = c * np.log(1 + image_gray)

        # Konversi hasil ke format uint8 (gambar 8 bit)
        log_transformed = np.array(log_transformed, dtype=np.uint8)

        # Menyimpan citra hasil transformasi sebagai Image object
        output_image = Image.fromarray(log_transformed)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil log brightness di kotak output (Kotak2)
        output_image.save("output_temp_log.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_log.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    
    def grayscale_quantization(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array menggunakan OpenCV
        image_np = np.array(image)
        
        # Mengubah gambar ke format grayscale menggunakan OpenCV
        image_gray = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Tentukan jumlah level kuantisasi
        level = 4  # Misalnya 4, bisa diubah sesuai kebutuhan

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(len(intervals)):
                lower_bound = intervals[i]
                upper_bound = lower_bound + interval_size - 1
                mask = (image >= lower_bound) & (image <= upper_bound)
                quantized_image[mask] = mid_values[i]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_gray, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def grayscale_quantization_1(self, level):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)
        
          # Tentukan jumlah level kuantisasi
        level = 2  # Misalnya 4, bisa diubah sesuai kebutuhan

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual untuk citra RGB
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(image.shape[2]):  # Untuk setiap saluran warna (R, G, B)
                channel = image[:, :, i]
                for j in range(len(intervals)):
                    lower_bound = intervals[j]
                    upper_bound = lower_bound + interval_size - 1
                    mask = (channel >= lower_bound) & (channel <= upper_bound)
                    quantized_image[:, :, i][mask] = mid_values[j]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_np, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())



    def grayscale_quantization_2(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)
        
          # Tentukan jumlah level kuantisasi
        level = 4  # Misalnya 4, bisa diubah sesuai kebutuhan

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual untuk citra RGB
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(image.shape[2]):  # Untuk setiap saluran warna (R, G, B)
                channel = image[:, :, i]
                for j in range(len(intervals)):
                    lower_bound = intervals[j]
                    upper_bound = lower_bound + interval_size - 1
                    mask = (channel >= lower_bound) & (channel <= upper_bound)
                    quantized_image[:, :, i][mask] = mid_values[j]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_np, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def grayscale_quantization_3(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)
        
          # Tentukan jumlah level kuantisasi
        level = 8  # Misalnya 4, bisa diubah sesuai kebutuhan

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual untuk citra RGB
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(image.shape[2]):  # Untuk setiap saluran warna (R, G, B)
                channel = image[:, :, i]
                for j in range(len(intervals)):
                    lower_bound = intervals[j]
                    upper_bound = lower_bound + interval_size - 1
                    mask = (channel >= lower_bound) & (channel <= upper_bound)
                    quantized_image[:, :, i][mask] = mid_values[j]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_np, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def grayscale_quantization_4(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)
        
          # Tentukan jumlah level kuantisasi
        level = 16  # Misalnya 4, bisa diubah sesuai kebutuhan

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual untuk citra RGB
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(image.shape[2]):  # Untuk setiap saluran warna (R, G, B)
                channel = image[:, :, i]
                for j in range(len(intervals)):
                    lower_bound = intervals[j]
                    upper_bound = lower_bound + interval_size - 1
                    mask = (channel >= lower_bound) & (channel <= upper_bound)
                    quantized_image[:, :, i][mask] = mid_values[j]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_np, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def grayscale_quantization_5(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)
        
          # Tentukan jumlah level kuantisasi
        level = 32  # Misalnya 4, bisa diubah sesuai kebutuhan

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual untuk citra RGB
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(image.shape[2]):  # Untuk setiap saluran warna (R, G, B)
                channel = image[:, :, i]
                for j in range(len(intervals)):
                    lower_bound = intervals[j]
                    upper_bound = lower_bound + interval_size - 1
                    mask = (channel >= lower_bound) & (channel <= upper_bound)
                    quantized_image[:, :, i][mask] = mid_values[j]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_np, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def grayscale_quantization_6(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)
        
          # Tentukan jumlah level kuantisasi
        level = 64  # Misalnya 4, bisa diubah sesuai kebutuhan

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual untuk citra RGB
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(image.shape[2]):  # Untuk setiap saluran warna (R, G, B)
                channel = image[:, :, i]
                for j in range(len(intervals)):
                    lower_bound = intervals[j]
                    upper_bound = lower_bound + interval_size - 1
                    mask = (channel >= lower_bound) & (channel <= upper_bound)
                    quantized_image[:, :, i][mask] = mid_values[j]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_np, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def grayscale_quantization_7(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)
        
          # Tentukan jumlah level kuantisasi
        level = 128  # Misalnya 4, bisa diubah sesuai kebutuhan

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual untuk citra RGB
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(image.shape[2]):  # Untuk setiap saluran warna (R, G, B)
                channel = image[:, :, i]
                for j in range(len(intervals)):
                    lower_bound = intervals[j]
                    upper_bound = lower_bound + interval_size - 1
                    mask = (channel >= lower_bound) & (channel <= upper_bound)
                    quantized_image[:, :, i][mask] = mid_values[j]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_np, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def grayscale_quantization_8(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array menggunakan OpenCV
        image_np = np.array(image)
        
        # Mengubah gambar ke format grayscale menggunakan OpenCV
        image_gray = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Tentukan jumlah level kuantisasi
        level = 256  # 8bit

        # Menentukan interval kuantisasi
        interval_size = 256 // level
        intervals = [i * interval_size for i in range(level)]
        mid_values = [((i * interval_size) + ((i + 1) * interval_size - 1)) // 2 for i in range(level)]

        # Fungsi kuantisasi manual
        def quantize(image, intervals, mid_values):
            quantized_image = np.zeros_like(image)
            for i in range(len(intervals)):
                lower_bound = intervals[i]
                upper_bound = lower_bound + interval_size - 1
                mask = (image >= lower_bound) & (image <= upper_bound)
                quantized_image[mask] = mid_values[i]
            return quantized_image

        # Terapkan kuantisasi
        quantized_image = quantize(image_gray, intervals, mid_values)

        # Menyimpan citra hasil kuantisasi sebagai Image object
        output_image = Image.fromarray(quantized_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil kuantisasi di kotak output (Kotak2)
        output_image.save("output_temp_quantization.jpg")  # Simpan sementara
        pixmap = QtGui.QPixmap("output_temp_quantization.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def inverse(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Melakukan invers pada nilai piksel
        inverted_image_np = 255 - image_np

        # Mengubah array kembali ke gambar
        inverted_image = Image.fromarray(inverted_image_np.astype(np.uint8))
        self.imageResult = inverted_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra invers sebagai Image object
        inverted_image.save("output_inverse_temp.jpg")  # Simpan sementara

        # Menampilkan gambar invers di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_inverse_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def log_brightness(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array dan mengubahnya ke format grayscale
        image_np = np.array(image.convert('L'))

        # Tentukan konstanta c berdasarkan rumus
        c = 255 / np.log(1 + np.max(image_np))

        # Terapkan transformasi log brightness
        log_transformed_np = c * np.log(1 + image_np)

        # Konversi hasil ke format uint8 (gambar 8 bit)
        log_transformed_np = np.array(log_transformed_np, dtype=np.uint8)

        # Mengubah array hasil ke gambar PIL
        log_transformed_image = Image.fromarray(log_transformed_np)
        self.imageResult = log_transformed_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra setelah log brightness sebagai Image object
        log_transformed_image.save("output_log_brightness_temp.jpg")  # Simpan sementara

        # Menampilkan gambar log brightness di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_log_brightness_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

        # Jika ingin menampilkan gambar menggunakan matplotlib, gunakan kode di bawah ini:
        plt.figure(figsize=(10, 4))

        plt.subplot(1, 2, 1)
        plt.title("Gambar Asli")
        plt.imshow(image_np, cmap='gray', vmin=0, vmax=255)
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.title("Setelah Log Brightness")
        plt.imshow(log_transformed_np, cmap='gray', vmin=0, vmax=255)
        plt.axis('off')

        plt.show()
    

        # Setup tampilan grafis, tambahkan kode setup tampilan Anda di sini

    def open_log_brightness_dialog(self):
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        self.log_brightness_dialog = LogBrightnessDialog(self)
        self.log_brightness_dialog.set_image(self.imagefile)
        self.log_brightness_dialog.imageProcessed.connect(self.display_image_result)  # Hubungkan sinyal dengan slot
        self.log_brightness_dialog.exec_()

    def display_image_result(self, image):
        # Simpan dan tampilkan gambar hasil di kotak kedua
        self.imageResult = image
        self.imageResult.save("output_log_brightness_result.jpg")
        
        pixmap = QtGui.QPixmap("output_log_brightness_result.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def open_linear_brightness_dialog(self):
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        self.linear_brightness_dialog = LinearBrightnessDialog(self)
        self.linear_brightness_dialog.set_image(self.imagefile)
        self.linear_brightness_dialog.imageProcessed.connect(self.display_image_result)  # Hubungkan sinyal dengan slot
        self.linear_brightness_dialog.exec_()

    def display_image_result(self, image):
        # Simpan dan tampilkan gambar hasil di kotak kedua
        self.imageResult = image
        self.imageResult.save("output_linear_brightness_result.jpg")
        
        pixmap = QtGui.QPixmap("output_linear_brightness_result.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def open_linear_contrast_dialog(self):
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        self.linear_contrast_dialog = LinearContrastDialog(self)
        self.linear_contrast_dialog.set_image(self.imagefile)
        self.linear_contrast_dialog.imageProcessed.connect(self.display_image_result)  # Hubungkan sinyal dengan slot
        self.linear_contrast_dialog.exec_()

    def display_image_result(self, image):
        # Simpan dan tampilkan gambar hasil di kotak kedua
        self.imageResult = image
        self.imageResult.save("output_linear_contrast_result.jpg")
        
        pixmap = QtGui.QPixmap("output_linear_contrast_result.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def open_linear_saturation_dialog(self):
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        self.linear_saturation_dialog = LinearSaturationDialog(self)
        self.linear_saturation_dialog.set_image(self.imagefile)
        self.linear_saturation_dialog.imageProcessed.connect(self.display_image_result)  # Hubungkan sinyal dengan slot
        self.linear_saturation_dialog.exec_()

    def display_image_result(self, image):
        # Simpan dan tampilkan gambar hasil di kotak kedua
        self.imageResult = image
        self.imageResult.save("output_linear_saturation_result.jpg")
        
        pixmap = QtGui.QPixmap("output_linear_saturation_result.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def open_linear_contrast_brightness_dialog(self):
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        self.linear_contrast_brightness_dialog = LinearContrastBrightnessDialog(self)
        self.linear_contrast_brightness_dialog.set_image(self.imagefile)
        self.linear_contrast_brightness_dialog.imageProcessed.connect(self.display_image_result)  # Hubungkan sinyal dengan slot
        self.linear_contrast_brightness_dialog.exec_()

    def display_image_result(self, image):
        # Simpan dan tampilkan gambar hasil di kotak kedua
        self.imageResult = image
        self.imageResult.save("output_linear_contrast_brightness_result.jpg")
        
        pixmap = QtGui.QPixmap("output_linear_contrast_brightness_result.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())



    def open_crop_dialog(self):
        print("Crop button clicked!")  # Debugging statement
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        try:
            self.crops_dialog = CropsDialog(self)
            self.crops_dialog.set_image(self.imagefile)  # Pastikan gambar di-set sebelum membuka dialog
            self.crops_dialog.imageCropped.connect(self.display_image_result)  # Connect signal
            self.crops_dialog.exec_()
        except Exception as e:
            print(f"Error opening crop dialog: {e}")

    def display_image_result(self, image):
        # Debugging statement
        print("Display image result called.")
        
        # Save the cropped image
        self.imageResult = image
        self.imageResult.save("output_cropped_image.jpg")

        # Display the cropped image in the second view
        pixmap = QtGui.QPixmap("output_cropped_image.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        # Assuming you have a QGraphicsView named `graphicsView_2` to display the image
        self.sceneOutput = QtWidgets.QGraphicsScene(self)
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setScene(self.sceneOutput)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def open_crop_dialog_region(self):
        print("Crop button clicked!")  # Debugging statement
        
        # Pastikan ada gambar yang telah di-load dan itu adalah objek gambar PIL
        if isinstance(self.imagefile, str):
            try:
                # Jika self.imagefile adalah path string, buka gambar dengan PIL
                print("Opening image from path:", self.imagefile)
                self.imagefile = Image.open(self.imagefile)  # Convert string to PIL Image
                print("Image successfully opened as PIL Image.")
            except Exception as e:
                QtWidgets.QMessageBox.warning(self, "Error", f"Failed to open image: {e}")
                return
        elif isinstance(self.imagefile, Image.Image):
            print("self.imagefile is already a PIL Image object.")
        else:
            print(f"Unexpected type for self.imagefile: {type(self.imagefile)}")
            QtWidgets.QMessageBox.warning(self, "Error", "The image is not a valid format.")
            return

        # Membuka dialog cropping
        try:
            # Membuat instance dari CropDialog dengan gambar yang telah di-load
            self.crops_dialog = CropDialog(self.imagefile, self)
            
            # Tampilkan dialog dan jalankan jika crop dilakukan
            if self.crops_dialog.exec_() == QtWidgets.QDialog.Accepted:
                # Ambil area cropping yang dipilih
                crop_rect = self.crops_dialog.get_crop_rect()

                # Proses gambar berdasarkan crop rect (misalnya memotong gambar)
                self.crop_image(crop_rect)
        except Exception as e:
            print(f"Error opening crop dialog: {e}")

    def crop_image(self, crop_rect):
        """Memotong gambar berdasarkan rectangle yang dipilih"""
        print(f"Cropping image with box: {crop_rect}")

        # Debugging tambahan untuk memastikan tipe dari self.imagefile
        print(f"Type of self.imagefile: {type(self.imagefile)}")
        
        # Pastikan self.imagefile adalah objek PIL Image dan crop_rect valid
        if isinstance(self.imagefile, Image.Image) and not crop_rect.isNull():
            try:
                # Mengonversi QRectF ke koordinat cropping (x, y, width, height)
                crop_box = (
                    int(crop_rect.left()), 
                    int(crop_rect.top()), 
                    int(crop_rect.right()), 
                    int(crop_rect.bottom())
                )

                print(f"Cropping box: {crop_box}")

                # Melakukan cropping pada imagefile (yang sekarang adalah objek PIL Image)
                cropped_image = self.imagefile.crop(crop_box)
                self.imageResult = cropped_image  # Simpan hasil crop
                
                # Simpan gambar yang sudah di-crop sementara
                self.imageResult.save("output_cropped_image_temp.jpg")

                # Tampilkan gambar yang sudah di-crop pada graphicsView_2 menggunakan QPixmap
                pixmap = QtGui.QPixmap("output_cropped_image_temp.jpg")
                scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

                # Hapus konten sebelumnya di sceneOutput dan tambahkan gambar hasil crop
                self.sceneOutput.clear()
                self.sceneOutput.addPixmap(scaled_pixmap)
                self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
                
            except Exception as e:
                print(f"Error cropping image: {e}")
        else:
            print(f"Invalid image or crop_rect: imagefile={self.imagefile}, crop_rect={crop_rect}")


    def open_translasi_dialog(self):
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        self.translasi_dialog = TranslasiDialog(self)
        self.translasi_dialog.set_image(self.imagefile)
        self.translasi_dialog.imageTranslated.connect(self.display_image_result)  # Connect signal
        self.translasi_dialog.exec_()

    def display_image_result(self, image):
        # Save the translated image
        self.imageResult = image
        self.imageResult.save("translated_image.jpg")

        # Display the translated image in the second view
        pixmap = QtGui.QPixmap("translated_image.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()  # Clear previous content
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def open_rotation_dialog(self):
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        self.rotasi_dialog = RotasiDialog(self)
        self.rotasi_dialog.set_image(self.imagefile)
        self.rotasi_dialog.imageRotated.connect(self.display_image_result)  # Connect signal to slot
        self.rotasi_dialog.exec_()

    def display_image_result(self, image):
        # Save and display the rotated image
        self.imageResult = image
        self.imageResult.save("rotated_image.jpg")
        
        pixmap = QtGui.QPixmap("rotated_image.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def open_zoom_dialog(self):
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        self.zoom_dialog = ZoomDialog(self)
        self.zoom_dialog.set_image(self.imagefile)
        self.zoom_dialog.imageZoomed.connect(self.display_image_result)  # Connect signal to slot
        self.zoom_dialog.exec_()

    def display_image_result(self, image):
        # Save and display the zoomed image
        self.imageResult = image
        self.imageResult.save("zoomed_image.jpg")
        
        pixmap = QtGui.QPixmap("zoomed_image.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
        
        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def flip_image_horzontal(self):
            # Check if an image is loaded
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        # Get the flip mode from the UI, default to 'horizontal' if not set
        mode = 'horizontal'  # Replace this with the actual method of retrieving mode if you have a control for it

        # Perform the flip operation
        if mode == 'horizontal':
            flipped_image = ImageOps.mirror(self.imagefile)
        elif mode == 'vertical':
            flipped_image = ImageOps.flip(self.imagefile)
        else:
            QtWidgets.QMessageBox.warning(self, "Invalid Mode", "Please select a valid flip mode.")
            return

        # Save the flipped image
        self.imageResult = flipped_image
        self.imageResult.save("flipped_image_temp.jpg")

        # Display the flipped image in the output box
        pixmap = QtGui.QPixmap("flipped_image_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Clear the previous content in the output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def flip_image_vertikal(self):
            # Check if an image is loaded
        if self.imagefile is None:
            QtWidgets.QMessageBox.warning(self, "No Image", "Please open an image first.")
            return

        # Get the flip mode from the UI, default to 'horizontal' if not set
        mode = 'vertical'  # Replace this with the actual method of retrieving mode if you have a control for it

        # Perform the flip operation
        if mode == 'horizontal':
            flipped_image = ImageOps.mirror(self.imagefile)
        elif mode == 'vertical':
            flipped_image = ImageOps.flip(self.imagefile)
        else:
            QtWidgets.QMessageBox.warning(self, "Invalid Mode", "Please select a valid flip mode.")
            return

        # Save the flipped image
        self.imageResult = flipped_image
        self.imageResult.save("flipped_image_temp.jpg")

        # Display the flipped image in the output box
        pixmap = QtGui.QPixmap("flipped_image_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Clear the previous content in the output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def tampilkan_histogram_citra_input(self):
        
        # Membuka citra menggunakan PIL dari atribut self
        image = self.imagefile

        # Mengonversi citra ke numpy array dan mengubahnya ke format BGR
        image_np = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)

        # Konversi citra dari BGR ke RGB
        image_rgb = cv2.cvtColor(image_np, cv2.COLOR_BGR2RGB)

        # Memisahkan kanal warna
        colors = ('red', 'green', 'blue')
        
        # Menyiapkan figure untuk histogram
        plt.figure(figsize=(15, 5))
        plt.suptitle('Histogram Input')
        
        # Menghitung dan menampilkan histogram untuk setiap kanal warna
        for i, color in enumerate(colors):
            plt.subplot(1, 3, i + 1)  # Membagi subplot untuk setiap warna
            histogram = cv2.calcHist([image_rgb], [i], None, [256], [0, 256])
            plt.plot(histogram, color=color)
            plt.title(f'{color.capitalize()} Channel')
            plt.xlabel('Pixel Intensity')
            plt.ylabel('Number of Pixels')
            plt.xlim([0, 256])

        # Menampilkan histogram
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.show()

        # Menyimpan gambar histogram sebagai Image object
        plt.savefig("output_histogram_temp.jpg")  # Simpan sementara
    
    def tampilkan_histogram_citra_output(self):
        # Membuka citra menggunakan PIL dari atribut self
        image = self.imageResult

        # Mengonversi citra ke numpy array dan mengubahnya ke format BGR
        image_np = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)

        # Konversi citra dari BGR ke RGB
        image_rgb = cv2.cvtColor(image_np, cv2.COLOR_BGR2RGB)

        # Memisahkan kanal warna
        colors = ('red', 'green', 'blue')
        
        # Menyiapkan figure untuk histogram
        plt.figure(figsize=(15, 5))
        plt.suptitle('Histogram Output')
        
        # Menghitung dan menampilkan histogram untuk setiap kanal warna
        for i, color in enumerate(colors):
            plt.subplot(1, 3, i + 1)  # Membagi subplot untuk setiap warna
            histogram = cv2.calcHist([image_rgb], [i], None, [256], [0, 256])
            plt.plot(histogram, color=color)
            plt.title(f'{color.capitalize()} Channel')
            plt.xlabel('Pixel Intensity')
            plt.ylabel('Number of Pixels')
            plt.xlim([0, 256])

        # Menampilkan histogram
        plt.tight_layout(rect=[0, 0.03, 1, 0.95])
        plt.show()

        # Menyimpan gambar histogram sebagai Image object
        plt.savefig("output_histogram_temp.jpg")  # Simpan sementara

        # # Menampilkan histogram di kotak output (Kotak2)
        # pixmap = QtGui.QPixmap("output_histogram_temp.jpg")
        # # scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        # self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        # self.sceneOutput.addPixmap(scaled_pixmap)
        # self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
    
    def tampilkan_histogram_citra_inputoutput(self):
        # Cek apakah self.imagefile dan self.imageResult ada
        if self.imagefile is None or self.imageResult is None:
            print("Citra input atau output tidak tersedia.")
            return

        # Histogram untuk citra input
        image_input = self.imagefile
        image_input_np = cv2.cvtColor(np.array(image_input), cv2.COLOR_RGB2BGR)
        image_input_rgb = cv2.cvtColor(image_input_np, cv2.COLOR_BGR2RGB)

        # Histogram untuk citra output
        image_output = self.imageResult
        image_output_np = cv2.cvtColor(np.array(image_output), cv2.COLOR_RGB2BGR)
        image_output_rgb = cv2.cvtColor(image_output_np, cv2.COLOR_BGR2RGB)

        # Setup untuk plotting histogram
        colors = ('red', 'green', 'blue')

        plt.figure(figsize=(15, 10))

        # Histogram untuk citra input
        plt.subplot(2, 1, 1)
        plt.title('Histogram Input')
        plt.xlabel('Intensitas pixel')
        plt.ylabel('Jumlah pixel')
        for i, color in enumerate(colors):
            histogram = cv2.calcHist([image_input_rgb], [i], None, [256], [0, 256])
            plt.plot(histogram, color=color)
        plt.xlim([0, 256])

        # Histogram untuk citra output
        plt.subplot(2, 1, 2)
        plt.title('Histogram Output')
        plt.xlabel('Intensitas pixel')
        plt.ylabel('Jumlah pixel')
        for i, color in enumerate(colors):
            histogram = cv2.calcHist([image_output_rgb], [i], None, [256], [0, 256])
            plt.plot(histogram, color=color)
        plt.xlim([0, 256])

        # Menampilkan histogram
        plt.tight_layout()
        plt.savefig("combined_histogram_temp.jpg")  # Simpan sementara
        plt.show()

        # # Menampilkan citra hasil pemrosesan di kotak output
        # image_output_pil = self.imageResult
        # image_output_qt = ImageQt.ImageQt(image_output_pil)
        # pixmap = QtGui.QPixmap.fromImage(image_output_qt)

        # self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        # self.sceneOutput.addPixmap(pixmap)
        # self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

        # # Menampilkan histogram di kotak output histogram
        # histogram_image = QtGui.QImage("combined_histogram_temp.jpg")
        # histogram_pixmap = QtGui.QPixmap.fromImage(histogram_image)
        # self.sceneOutputHistogram.clear()  # Hapus konten sebelumnya di output histogram scene
        # self.sceneOutputHistogram.addPixmap(histogram_pixmap)
        # self.graphicsViewHistogram.setSceneRect(self.sceneOutputHistogram.itemsBoundingRect())

    
    def tampilkan_histogram_citra(self):
        # Membuka citra menggunakan PIL dari atribut self
        image = self.imagefile

        # Mengonversi citra ke numpy array dan mengubahnya ke format BGR
        image_np = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)

        # Konversi citra dari BGR ke RGB
        image_rgb = cv2.cvtColor(image_np, cv2.COLOR_BGR2RGB)

        # Memisahkan kanal warna
        colors = ('red', 'green', 'blue')

        plt.figure(figsize=(10, 5))
        plt.title('Histogram untuk setiap kanal warna')
        plt.xlabel('Intensitas pixel')
        plt.ylabel('Jumlah pixel')

        # Menghitung dan menampilkan histogram untuk setiap kanal warna
        for i, color in enumerate(colors):
            histogram = cv2.calcHist([image_rgb], [i], None, [256], [0, 256])
            plt.plot(histogram, color=color)
            plt.xlim([0, 256])

        # Menampilkan histogram
        plt.show()

        # Menyimpan gambar histogram sebagai Image object
        plt.savefig("output_histogram_temp.jpg")  # Simpan sementara

        # Menampilkan histogram di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_histogram_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def histogram_equalization(self):
        # Membuka citra menggunakan PIL dari atribut self
        image = self.imagefile

        # Mengonversi citra ke numpy array dan mengubahnya ke format grayscale
        image_np = np.array(image.convert('L'))

        # Melakukan histogram equalization
        equalized_image_np = cv2.equalizeHist(image_np)

        # Mengubah array hasil equalization kembali ke gambar PIL
        equalized_image = Image.fromarray(equalized_image_np)
        self.imageResult = equalized_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra equalized sebagai Image object
        equalized_image.save("output_equalized_temp.jpg")  # Simpan sementara

        # Menampilkan gambar equalized di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_equalized_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

        # Jika ingin menampilkan gambar menggunakan matplotlib, gunakan kode di bawah ini:
        plt.figure(figsize=(12, 6))
        plt.subplot(1, 2, 1)
        plt.title('Gambar Asli')
        plt.imshow(image_np, cmap='gray')
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.title('Gambar setelah Equalization')
        plt.imshow(equalized_image_np, cmap='gray')
        plt.axis('off')

        plt.show()

    def fuzzy_histogram_equalization(self):
        # Load gambar grayscale dari atribut self
        image = cv2.imread(self.imagePath, cv2.IMREAD_GRAYSCALE)

        # Fungsi untuk menghitung fuzzy histogram equalization
        def fuzzy_histogram_equalization_grayscale(image):
            # Ambil histogram dari gambar
            hist, bins = np.histogram(image.flatten(), 256, [0, 256])

            # Terapkan fuzzy histogram equalization
            fuzzy_hist = fuzzy_membership(hist)

            # Hitung cumulative distribution function (CDF)
            cdf = fuzzy_hist.cumsum()
            cdf_normalized = cdf * hist.max() / cdf.max()  # Normalisasi

            # Gunakan CDF untuk histogram equalization
            cdf_m = np.ma.masked_equal(cdf, 0)
            cdf_m = (cdf_m - cdf_m.min()) * 255 / (cdf_m.max() - cdf_m.min())
            cdf_final = np.ma.filled(cdf_m, 0).astype('uint8')

            # Mapping nilai pixel berdasarkan CDF yang diubah
            img_equalized = cdf_final[image]

            return img_equalized

        # Fungsi untuk menghitung fuzzy membership
        def fuzzy_membership(hist):
            # Membuat fuzzy histogram dengan fungsi keanggotaan tertentu
            # Menggunakan fungsi sigmoid sebagai fungsi keanggotaan fuzzy
            fuzzy_hist = 1 / (1 + np.exp(-hist))

            # Normalisasi fuzzy histogram
            fuzzy_hist = fuzzy_hist / fuzzy_hist.sum()

            return fuzzy_hist

        # Lakukan fuzzy histogram equalization pada gambar
        fhe_image = fuzzy_histogram_equalization_grayscale(image)

        # Konversi hasil equalization ke image PIL
        output_image = Image.fromarray(fhe_image)
        self.imageResult = output_image  # Simpan hasil untuk keperluan lainnya

        # Simpan gambar hasil FHE ke temporary file
        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as temp_file:
            temp_file_path = temp_file.name
            output_image.save(temp_file_path)

        # Load image dari temporary file ke QPixmap untuk ditampilkan
        pixmap = QtGui.QPixmap(temp_file_path)

        # Dapatkan ukuran dari QGraphicsView untuk scaling
        view_width = self.graphicsView_2.width()
        view_height = self.graphicsView_2.height()

        # Scale pixmap ke ukuran QGraphicsView
        scaled_pixmap = pixmap.scaled(view_width, view_height, QtCore.Qt.KeepAspectRatio)

        # Hapus gambar sebelumnya di QGraphicsView dan tampilkan yang baru
        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

        # Hapus temporary file setelah digunakan
        os.remove(temp_file_path)

        # Jika ingin menampilkan gambar menggunakan matplotlib
        plt.figure(figsize=(12, 6))
        plt.subplot(1, 2, 1)
        plt.title('Gambar Asli')
        plt.imshow(image, cmap='gray')
        plt.axis('off')

        plt.subplot(1, 2, 2)
        plt.title('Gambar setelah FHE')
        plt.imshow(fhe_image, cmap='gray')
        plt.axis('off')

        plt.show()


    def fhe_rgb(self):
        # Membuka citra menggunakan PIL (self.imagefile sudah merupakan objek gambar PIL)
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Fungsi untuk melakukan fuzzy histogram equalization pada gambar RGB
        def fuzzy_histogram_equalization_rgb(image_np):
            # Pisahkan menjadi 3 channel: Red, Green, Blue
            r, g, b = cv2.split(image_np)

            # Lakukan fuzzy histogram equalization untuk setiap channel
            r_eq = fuzzy_histogram_equalization(r)
            g_eq = fuzzy_histogram_equalization(g)
            b_eq = fuzzy_histogram_equalization(b)

            # Gabungkan kembali channel-channel yang sudah diproses
            img_eq = cv2.merge((r_eq, g_eq, b_eq))

            return img_eq

        # Fungsi untuk fuzzy histogram equalization pada satu channel
        def fuzzy_histogram_equalization(channel):
            # Ambil histogram
            hist, bins = np.histogram(channel.flatten(), 256, [0, 256])

            # Fungsi keanggotaan fuzzy
            fuzzy_hist = fuzzy_membership(hist)

            # Hitung cumulative distribution function (CDF)
            cdf = fuzzy_hist.cumsum()
            cdf_normalized = cdf * hist.max() / cdf.max()  # Normalisasi

            # Gunakan CDF untuk histogram equalization
            cdf_m = np.ma.masked_equal(cdf, 0)
            cdf_m = (cdf_m - cdf_m.min()) * 255 / (cdf_m.max() - cdf_m.min())
            cdf_final = np.ma.filled(cdf_m, 0).astype('uint8')

            # Mapping nilai pixel berdasarkan CDF yang diubah
            img_equalized = cdf_final[channel]

            return img_equalized

        # Fungsi untuk menghitung fuzzy membership
        def fuzzy_membership(hist):
            # Membuat fuzzy histogram dengan fungsi keanggotaan tertentu
            # Misalnya, menggunakan fungsi sigmoid sebagai dasar fuzzy
            fuzzy_hist = 1 / (1 + np.exp(-hist))  # Fungsi sigmoid

            # Normalisasi fuzzy histogram
            fuzzy_hist = fuzzy_hist / fuzzy_hist.sum()

            return fuzzy_hist

        # Lakukan fuzzy histogram equalization pada gambar RGB
        fhe_rgb_np = fuzzy_histogram_equalization_rgb(image_np)

        # Mengubah array kembali ke gambar PIL
        fhe_rgb_image = Image.fromarray(fhe_rgb_np.astype(np.uint8))
        self.imageResult = fhe_rgb_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil FHE sebagai file sementara
        fhe_rgb_image.save("output_fhe_temp.jpg")  # Simpan sementara

        # Menampilkan gambar hasil FHE di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_fhe_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())



    def color_yellow(self):
        if self.imagefile is not None:
            # Membuka citra menggunakan PIL
            image = self.imagefile
            
            # Mengonversi citra ke numpy array
            image_np = np.array(image)

            # Terapkan filter kuning
            yellow_image_np = self.apply_yellow_filter(image_np)

            # Mengubah array kembali ke gambar
            yellow_image = Image.fromarray(yellow_image_np.astype(np.uint8))
            self.imageResult = yellow_image  # Simpan hasil untuk keperluan save

            # Menyimpan citra kuning sebagai Image object
            yellow_image.save("output_yellow_temp.jpg")  # Simpan sementara

            # Menampilkan gambar kuning di kotak output (Kotak2)
            pixmap = QtGui.QPixmap("output_yellow_temp.jpg")
            scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

            self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
            self.sceneOutput.addPixmap(scaled_pixmap)
            self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def apply_yellow_filter(self, image_np):
        # Terapkan filter kuning
        yellow_image_np = np.copy(image_np)
        yellow_image_np[:, :, 0] = np.clip(yellow_image_np[:, :, 0] + 100, 0, 255)  # Tingkatkan kanal Merah
        yellow_image_np[:, :, 1] = np.clip(yellow_image_np[:, :, 1] + 100, 0, 255)  # Tingkatkan kanal Hijau
        # Kanal Biru tetap tidak berubah

        return yellow_image_np


    def regionGrowing(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array (dalam grayscale)
        image_np = np.array(image.convert('L'))

        # Tentukan titik awal (seed point) dan nilai threshold
        seed = (10, 10)  # Contoh seed point
        threshold_value = 20  # Nilai ambang batas

        # Ukuran gambar
        h, w = image_np.shape
        segmented = np.zeros((h, w), dtype=np.uint8)
        segmented[seed] = 255
        region_intensity = image_np[seed]

        # Daftar titik yang akan diperiksa
        to_check = [seed]

        # Algoritma Region Growing
        while to_check:
            current_point = to_check.pop(0)
            for dx in [-1, 0, 1]:
                for dy in [-1, 0, 1]:
                    x, y = current_point[0] + dx, current_point[1] + dy
                    if 0 <= x < h and 0 <= y < w and segmented[x, y] == 0:
                        if abs(int(image_np[x, y]) - int(region_intensity)) <= threshold_value:
                            segmented[x, y] = 255
                            to_check.append((x, y))

        # Mengubah array kembali ke gambar
        segmented_image = Image.fromarray(segmented.astype(np.uint8))
        self.imageResult = segmented_image  # Simpan hasil untuk keperluan save

        # Simpan sementara
        segmented_image.save("output_region_growing_temp.jpg")

        # Menampilkan gambar hasil segmentasi di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_region_growing_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def kmeansClustering(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image.convert('L'))  # Ubah gambar ke grayscale

        # Mengambil input K dari pengguna melalui antarmuka
        k, ok = QtWidgets.QInputDialog.getInt(self, "Input K", "Masukkan jumlah kluster (K):", 2, 1, 10, 1)

        if ok:  # Jika pengguna menginput nilai
            pixel_values = image_np.reshape((-1, 1))
            pixel_values = np.float32(pixel_values)

            # definisikan kriteria untuk algoritma K-Means
            criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.2)
            _, labels, centers = cv2.kmeans(pixel_values, k, None, criteria, 10, cv2.KMEANS_RANDOM_CENTERS)

            # Ubah label menjadi citra hasil klaster
            centers = np.uint8(centers)
            segmented_image = centers[labels.flatten()]
            segmented_image = segmented_image.reshape(image_np.shape)

            # Mengubah array kembali ke gambar
            segmented_image_pil = Image.fromarray(segmented_image.astype(np.uint8))
            self.imageResult = segmented_image_pil  # Simpan hasil untuk keperluan save

            # Simpan sementara
            segmented_image_pil.save("output_kmeans_temp.jpg")

            # Menampilkan gambar hasil klasterisasi di kotak output (graphicsView_2)
            pixmap = QtGui.QPixmap("output_kmeans_temp.jpg")
            scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

            self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
            self.sceneOutput.addPixmap(scaled_pixmap)
            self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def watershedSegmentation(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array dan pastikan dalam bentuk grayscale
        image_np = np.array(image.convert('L'))

        # Binarisasi citra menggunakan thresholding OTSU
        _, thresh = cv2.threshold(image_np, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)

        # Menggunakan morfologi untuk menghilangkan noise
        kernel = np.ones((3, 3), np.uint8)
        opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel, iterations=2)

        # Menentukan sure background dan sure foreground
        sure_bg = cv2.dilate(opening, kernel, iterations=3)
        dist_transform = cv2.distanceTransform(opening, cv2.DIST_L2, 5)
        _, sure_fg = cv2.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)

        # Mendapatkan region yang tidak diketahui
        sure_fg = np.uint8(sure_fg)
        unknown = cv2.subtract(sure_bg, sure_fg)

        # Label marker
        _, markers = cv2.connectedComponents(sure_fg)
        markers = markers + 1
        markers[unknown == 255] = 0

        # Melakukan watershed pada gambar warna
        markers = cv2.watershed(cv2.cvtColor(image_np, cv2.COLOR_GRAY2BGR), markers)
        image_np[markers == -1] = 255  # Menggambar garis watershed pada gambar

        # Mengubah array kembali ke gambar
        segmented_image_pil = Image.fromarray(image_np.astype(np.uint8))
        self.imageResult = segmented_image_pil  # Simpan hasil untuk keperluan save

        # Simpan sementara hasil segmentasi watershed
        segmented_image_pil.save("output_watershed_temp.jpg")

        # Menampilkan gambar hasil segmentasi di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_watershed_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def globalThresholding(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array (grayscale)
        image_np = np.array(image.convert('L'))  # Konversi gambar ke grayscale

        # Mengambil input threshold dari pengguna melalui antarmuka
        threshold_value, ok = QtWidgets.QInputDialog.getInt(self, "Input Threshold", "Masukkan nilai threshold:", 100, 0, 255, 1)

        if ok:  # Jika pengguna menginput nilai
            # Lakukan thresholding global
            _, binary_image = cv2.threshold(image_np, threshold_value, 255, cv2.THRESH_BINARY)

            # Mengubah array hasil threshold menjadi gambar PIL untuk ditampilkan
            binary_image_pil = Image.fromarray(binary_image.astype(np.uint8))

            # Menyimpan hasil gambar sementara
            binary_image_pil.save("output_thresholding_temp.jpg")

            # Tampilkan gambar di GUI menggunakan PyQt5
            pixmap = QtGui.QPixmap("output_thresholding_temp.jpg")
            scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

            # Membersihkan dan menampilkan gambar hasil thresholding di graphicsView
            self.sceneOutput.clear()
            self.sceneOutput.addPixmap(scaled_pixmap)
            self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def adaptive_thesholding(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array (grayscale)
        image_np = np.array(image.convert('L'))  # Konversi gambar ke grayscale

        # Mengambil input block size dan constant dari pengguna melalui antarmuka
        block_size, ok1 = QtWidgets.QInputDialog.getInt(self, "Input Block Size", "Masukkan block size (harus ganjil):", 11, 3, 51, 2)
        constant, ok2 = QtWidgets.QInputDialog.getInt(self, "Input Constant", "Masukkan nilai konstanta:", 2, 0, 10, 1)

        if ok1 and ok2:  # Jika pengguna menginput nilai
            # Lakukan adaptive thresholding
            adaptive_thresh_mean = cv2.adaptiveThreshold(image_np, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, block_size, constant)
            adaptive_thresh_gaussian = cv2.adaptiveThreshold(image_np, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, block_size, constant)

            # Mengubah array hasil threshold menjadi gambar PIL untuk ditampilkan
            mean_pil = Image.fromarray(adaptive_thresh_mean.astype(np.uint8))
            gaussian_pil = Image.fromarray(adaptive_thresh_gaussian.astype(np.uint8))

            # Menyimpan hasil gambar sementara
            mean_pil.save("output_adaptive_mean_temp.jpg")
            gaussian_pil.save("output_adaptive_gaussian_temp.jpg")

            # Tampilkan gambar di GUI menggunakan PyQt5
            pixmap_mean = QtGui.QPixmap("output_adaptive_mean_temp.jpg")
            pixmap_gaussian = QtGui.QPixmap("output_adaptive_gaussian_temp.jpg")

            scaled_pixmap_mean = pixmap_mean.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)
            scaled_pixmap_gaussian = pixmap_gaussian.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

            # Membersihkan dan menampilkan gambar hasil adaptive thresholding di graphicsView
            self.sceneOutput.clear()
            self.sceneOutput.addPixmap(scaled_pixmap_mean)
            self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
            # Menampilkan gambar gaussian (misalnya di widget lain)
            self.sceneOutput.clear()
            self.sceneOutput.addPixmap(scaled_pixmap_gaussian)
            self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def segment_adaptive_thresh_mean(self):
        # Membuka citra menggunakan self.imagefile
        image = self.imagefile

        # Mengonversi citra ke numpy array (grayscale)
        image_np = np.array(image.convert("L"))

        # Terapkan thresholding adaptif mean
        adaptive_thresh_mean = cv2.adaptiveThreshold(image_np, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                                                    cv2.THRESH_BINARY, 11, 2)

        # Mengubah array kembali ke gambar
        adaptive_mean_image_pil = Image.fromarray(adaptive_thresh_mean)

        # Simpan hasil sementara
        adaptive_mean_image_pil.save("output_adaptive_mean_temp.png")
        self.imageResult = adaptive_mean_image_pil  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_adaptive_mean_temp.png")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

        # Hapus file sementara
        os.remove("output_adaptive_mean_temp.png")

    def segment_adaptive_thresh_gaussian(self):
        # Membuka citra menggunakan self.imagefile
        image = self.imagefile

        # Mengonversi citra ke numpy array (grayscale)
        image_np = np.array(image.convert("L"))

        # Terapkan thresholding adaptif Gaussian
        adaptive_thresh_gaussian = cv2.adaptiveThreshold(image_np, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                                        cv2.THRESH_BINARY, 11, 2)

        # Mengubah array kembali ke gambar
        adaptive_gaussian_image_pil = Image.fromarray(adaptive_thresh_gaussian)

        # Simpan hasil sementara
        adaptive_gaussian_image_pil.save("output_adaptive_gaussian_temp.png")
        self.imageResult = adaptive_gaussian_image_pil  # Simpan hasil untuk keperluan save

        # Menampilkan gambar hasil di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_adaptive_gaussian_temp.png")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

        # Hapus file sementara
        os.remove("output_adaptive_gaussian_temp.png")






    def erosion_square_3(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array (akan tetap dalam RGB jika citra berwarna)
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel square 3x3
        kernel = np.ones((3, 3), np.uint8)

        # Melakukan operasi erosi
        erosion_img = cv2.erode(binary_img, kernel, iterations=1)

        # Mengubah array hasil erosi kembali ke gambar
        erosion_image = Image.fromarray(erosion_img.astype(np.uint8))
        self.imageResult = erosion_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil erosi sebagai Image object sementara
        erosion_image.save("output_erosion_square3_temp.jpg")

        # Menampilkan gambar hasil erosi di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_erosion_square3_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    
    def erosion_square_5(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array (akan tetap dalam RGB jika citra berwarna)
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel square 3x3
        kernel = np.ones((5, 5), np.uint8)

        # Melakukan operasi erosi
        erosion_img = cv2.erode(binary_img, kernel, iterations=1)

        # Mengubah array hasil erosi kembali ke gambar
        erosion_image = Image.fromarray(erosion_img.astype(np.uint8))
        self.imageResult = erosion_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil erosi sebagai Image object sementara
        erosion_image.save("output_erosion_square5_temp.jpg")

        # Menampilkan gambar hasil erosi di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_erosion_square5_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def erosion_cross_3(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel cross 3x3
        kernel = np.array([[0, 1, 0],
                        [1, 1, 1],
                        [0, 1, 0]], np.uint8)

        # Melakukan operasi erosi
        erosion_img = cv2.erode(binary_img, kernel, iterations=1)

        # Mengubah array hasil erosi kembali ke gambar
        erosion_image = Image.fromarray(erosion_img.astype(np.uint8))
        self.imageResult = erosion_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil erosi sebagai Image object sementara
        erosion_image.save("output_erosion_cross3_temp.jpg")

        # Menampilkan gambar hasil erosi di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_erosion_cross3_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def dilation_square_3(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel square 3x3
        kernel = np.ones((3, 3), np.uint8)

        # Melakukan operasi dilasi
        dilation_img = cv2.dilate(binary_img, kernel, iterations=1)

        # Mengubah array hasil dilasi kembali ke gambar
        dilation_image = Image.fromarray(dilation_img.astype(np.uint8))
        self.imageResult = dilation_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil dilasi sebagai Image object sementara
        dilation_image.save("output_dilation_square3_temp.jpg")

        # Menampilkan gambar hasil dilasi di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_dilation_square3_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def dilation_square_5(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel square 3x3
        kernel = np.ones((5, 5), np.uint8)

        # Melakukan operasi dilasi
        dilation_img = cv2.dilate(binary_img, kernel, iterations=1)

        # Mengubah array hasil dilasi kembali ke gambar
        dilation_image = Image.fromarray(dilation_img.astype(np.uint8))
        self.imageResult = dilation_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil dilasi sebagai Image object sementara
        dilation_image.save("output_dilation_square5_temp.jpg")

        # Menampilkan gambar hasil dilasi di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_dilation_square5_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def dilation_cross_3(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel cross 3x3
        kernel = np.array([[0, 1, 0],
                        [1, 1, 1],
                        [0, 1, 0]], np.uint8)

        # Melakukan operasi dilasi
        dilation_img = cv2.dilate(binary_img, kernel, iterations=1)

        # Mengubah array hasil dilasi kembali ke gambar
        dilation_image = Image.fromarray(dilation_img.astype(np.uint8))
        self.imageResult = dilation_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil dilasi sebagai Image object sementara
        dilation_image.save("output_dilation_cross3_temp.jpg")

        # Menampilkan gambar hasil dilasi di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_dilation_cross3_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def opening_square_9(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel square 9x9
        kernel = np.ones((9, 9), np.uint8)

        # Melakukan operasi Opening (erosi diikuti dilasi)
        opening_img = cv2.morphologyEx(binary_img, cv2.MORPH_OPEN, kernel)

        # Mengubah array hasil opening kembali ke gambar
        opening_image = Image.fromarray(opening_img.astype(np.uint8))
        self.imageResult = opening_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil opening sebagai Image object sementara
        opening_image.save("output_opening_square9_temp.jpg")

        # Menampilkan gambar hasil opening di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_opening_square9_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def closing_square_9(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel square 9x9
        kernel = np.ones((9, 9), np.uint8)

        # Melakukan operasi Closing (dilasi diikuti erosi)
        closing_img = cv2.morphologyEx(binary_img, cv2.MORPH_CLOSE, kernel)

        # Mengubah array hasil closing kembali ke gambar
        closing_image = Image.fromarray(closing_img.astype(np.uint8))
        self.imageResult = closing_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil closing sebagai Image object sementara
        closing_image.save("output_closing_square9_temp.jpg")

        # Menampilkan gambar hasil closing di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_closing_square9_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def hit_or_miss(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Membuat kernel Hit-or-Miss
        kernel_hitmiss = np.array([[1, 1, 1],
                                [0, 1, 0],
                                [-1, -1, -1]], dtype=np.int8)

        # Melakukan operasi Hit-or-Miss
        hit_or_miss_img = cv2.morphologyEx(binary_img, cv2.MORPH_HITMISS, kernel_hitmiss)

        # Mengubah array hasil Hit-or-Miss kembali ke gambar
        hit_or_miss_image = Image.fromarray(hit_or_miss_img.astype(np.uint8))
        self.imageResult = hit_or_miss_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil Hit-or-Miss sebagai Image object sementara
        hit_or_miss_image.save("output_hit_or_miss_temp.jpg")

        # Menampilkan gambar hasil Hit-or-Miss di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_hit_or_miss_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def thinning(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Pastikan gambar biner dalam tipe data uint8
        binary_img = binary_img.astype(np.uint8)

        # Melakukan operasi Thinning
        thinned_img = thin(binary_img // 255) * 255  # Menggunakan skimage untuk melakukan penipisan

        # Mengubah array hasil Thinning kembali ke gambar
        thinned_image = Image.fromarray(thinned_img.astype(np.uint8))
        self.imageResult = thinned_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil Thinning sebagai Image object sementara
        thinned_image.save("output_thinning_temp.jpg")

        # Menampilkan gambar hasil Thinning di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_thinning_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def thickening(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Pastikan gambar biner dalam tipe data uint8
        binary_img = binary_img.astype(np.uint8)

        # Membuat kernel untuk operasi morfologi
        kernel = np.ones((3, 3), np.uint8)  # Kernel 3x3 untuk morfologi

        # Melakukan operasi Erosi
        erosion = cv2.erode(binary_img, kernel, iterations=1)

        # Melakukan operasi Dilasi
        dilation = cv2.dilate(binary_img, kernel, iterations=1)

        # Melakukan Thickening (Penebalan)
        thickened_img = dilation - erosion

        # Mengubah array hasil Thickening kembali ke gambar
        thickened_image = Image.fromarray(thickened_img.astype(np.uint8))
        self.imageResult = thickened_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil Thickening sebagai Image object sementara
        thickened_image.save("output_thickening_temp.jpg")

        # Menampilkan gambar hasil Thickening di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_thickening_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def skeletonization(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Pastikan gambar biner dalam tipe data uint8
        binary_img = binary_img.astype(np.uint8)

        # Melakukan Skeletonization menggunakan skimage
        skeleton = skeletonize(binary_img // 255) * 255  # Membagi dengan 255 untuk mengubah menjadi 0 dan 1, kemudian dikalikan 255 untuk hasil biner

        # Mengubah array hasil skeletonization kembali ke gambar
        skeleton_image = Image.fromarray(skeleton.astype(np.uint8))
        self.imageResult = skeleton_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil Skeletonization sebagai Image object sementara
        skeleton_image.save("output_skeleton_temp.jpg")

        # Menampilkan gambar hasil Skeletonization di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_skeleton_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def prune_skeleton(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Jika gambar berwarna (3 channel), konversi ke grayscale
        if len(image_np.shape) == 3:
            image_np = cv2.cvtColor(image_np, cv2.COLOR_RGB2GRAY)

        # Mengonversi gambar grayscale menjadi biner menggunakan threshold
        _, binary_img = cv2.threshold(image_np, 127, 255, cv2.THRESH_BINARY)

        # Pastikan gambar biner dalam tipe data uint8
        binary_img = binary_img.astype(np.uint8)

        # Melakukan Skeletonization menggunakan skimage
        skeleton = skeletonize(binary_img // 255) * 255  # Skeletonization

        # Membuat kernel hit-or-miss
        kernel_hitmiss = np.array([[1, 1, 1],
                                    [0, 1, 0],
                                    [-1, -1, -1]])

        # Mengimplementasikan fungsi pruning
        pruned_img = skeleton.copy().astype(np.uint8)  # Salin citra kerangka
        for _ in range(2):  # Iterasi pruning, bisa disesuaikan
            pruned_img = cv2.morphologyEx(pruned_img, cv2.MORPH_HITMISS, kernel_hitmiss)

        # Mengubah array hasil pruning kembali ke gambar
        pruned_image = Image.fromarray(pruned_img.astype(np.uint8))
        self.imageResult = pruned_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hasil Pruning sebagai Image object sementara
        pruned_image.save("output_pruning_temp.jpg")

        # Menampilkan gambar hasil Pruning di kotak output (graphicsView_2)
        pixmap = QtGui.QPixmap("output_pruning_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def sobel(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array dan mengubah ke grayscale
        image_np = np.array(image.convert('L'))  # Mengubah ke grayscale

        # Terapkan operator Sobel untuk gradien horizontal dan vertikal
        sobel_x = cv2.Sobel(image_np, cv2.CV_64F, 1, 0, ksize=3)  # Gradien horizontal
        sobel_y = cv2.Sobel(image_np, cv2.CV_64F, 0, 1, ksize=3)  # Gradien vertikal

        # Kombinasikan hasil dari gradien X dan Y menggunakan magnitude
        sobel_combined = np.sqrt(np.square(sobel_x) + np.square(sobel_y))

        # Normalisasi hasil Sobel ke rentang 0-255
        sobel_combined = (sobel_combined / np.max(sobel_combined)) * 255
        sobel_combined = sobel_combined.astype(np.uint8)

        # Mengubah array hasil menjadi gambar PIL untuk ditampilkan
        sobel_image_pil = Image.fromarray(sobel_combined)

        # Menyimpan hasil gambar sementara
        sobel_image_pil.save("output_sobel_temp.jpg")

        # Tampilkan gambar di GUI menggunakan PyQt5
        pixmap = QtGui.QPixmap("output_sobel_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        # Membersihkan dan menampilkan gambar hasil deteksi tepi Sobel di graphicsView
        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def prewitt(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array dan mengubah ke grayscale
        image_np = np.array(image.convert('L'))  # Mengubah ke grayscale

        # Terapkan operator Prewitt secara manual
        prewitt_x = cv2.filter2D(image_np, -1, np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]]))  # Gradien Horizontal
        prewitt_y = cv2.filter2D(image_np, -1, np.array([[1, 1, 1], [0, 0, 0], [-1, -1, -1]]))  # Gradien Vertikal

        # Kombinasikan hasil dari gradien X dan Y
        prewitt_combined = np.sqrt(np.square(prewitt_x) + np.square(prewitt_y))

        # Normalisasi hasil Prewitt ke rentang 0-255
        prewitt_combined = (prewitt_combined / np.max(prewitt_combined)) * 255
        prewitt_combined = prewitt_combined.astype(np.uint8)

        # Mengubah array hasil menjadi gambar PIL untuk ditampilkan
        prewitt_image_pil = Image.fromarray(prewitt_combined)

        # Menyimpan hasil gambar sementara
        prewitt_image_pil.save("output_prewitt_temp.jpg")

        # Tampilkan gambar di GUI menggunakan PyQt5
        pixmap = QtGui.QPixmap("output_prewitt_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        # Membersihkan dan menampilkan gambar hasil deteksi tepi Prewitt di graphicsView
        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def canny(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array dan mengubah ke grayscale
        image_np = np.array(image.convert('L'))  # Mengubah ke grayscale

        # Terapkan deteksi tepi Canny
        canny_edges = cv2.Canny(image_np, 100, 200)

        # Mengubah array hasil menjadi gambar PIL untuk ditampilkan
        canny_image_pil = Image.fromarray(canny_edges)

        # Menyimpan hasil gambar sementara
        canny_image_pil.save("output_canny_temp.jpg")

        # Tampilkan gambar di GUI menggunakan PyQt5
        pixmap = QtGui.QPixmap("output_canny_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        # Membersihkan dan menampilkan gambar hasil deteksi tepi Canny di graphicsView
        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())


    def identity(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel identity (tidak mengubah citra)
        kernel_identity = np.array([[0, 0, 0], [0, 1, 0], [0, 0, 0]])

        # Menggunakan filter2D dari OpenCV untuk menerapkan kernel identity
        identity_image_np = cv2.filter2D(image_np, -1, kernel_identity)

        # Mengubah array kembali ke gambar
        identity_image = Image.fromarray(identity_image_np.astype(np.uint8))
        self.imageResult = identity_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra sebagai Image object sementara
        identity_image.save("output_identity_temp.jpg")  # Simpan sementara

        # Menampilkan gambar di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_identity_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def edge_detection_1(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel edge detection 1
        kernel_edge_detection_1 = np.array([[1, 0, -1], [0, 0, 0], [-1, 0, 1]])

        # Menggunakan filter2D dari OpenCV untuk menerapkan kernel edge detection 1
        edge_image_np = cv2.filter2D(image_np, -1, kernel_edge_detection_1)

        # Mengubah array kembali ke gambar
        edge_image = Image.fromarray(edge_image_np.astype(np.uint8))
        self.imageResult = edge_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra sebagai Image object sementara
        edge_image.save("output_edge1_temp.jpg")  # Simpan sementara

        # Menampilkan gambar di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_edge1_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def edge_detection_2(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel edge detection 2
        kernel_edge_detection_2 = np.array([[0, 1, 0], [1, -4, 1], [0, 1, 0]])

        # Menggunakan filter2D dari OpenCV untuk menerapkan kernel edge detection 2
        edge_image_np = cv2.filter2D(image_np, -1, kernel_edge_detection_2)

        # Mengubah array kembali ke gambar
        edge_image = Image.fromarray(edge_image_np.astype(np.uint8))
        self.imageResult = edge_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra sebagai Image object sementara
        edge_image.save("output_edge2_temp.jpg")  # Simpan sementara

        # Menampilkan gambar di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_edge2_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def edge_detection_3(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel edge detection 3
        kernel_edge_detection_3 = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])

        # Menggunakan filter2D dari OpenCV untuk menerapkan kernel edge detection 3
        edge_image_np = cv2.filter2D(image_np, -1, kernel_edge_detection_3)

        # Mengubah array kembali ke gambar
        edge_image = Image.fromarray(edge_image_np.astype(np.uint8))
        self.imageResult = edge_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra sebagai Image object sementara
        edge_image.save("output_edge3_temp.jpg")  # Simpan sementara

        # Menampilkan gambar di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_edge3_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def sharpen(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel sharpen
        kernel_sharpen = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]])

        # Menggunakan filter2D dari OpenCV untuk menerapkan kernel sharpen
        sharpened_image_np = cv2.filter2D(image_np, -1, kernel_sharpen)

        # Mengubah array kembali ke gambar
        sharpened_image = Image.fromarray(sharpened_image_np.astype(np.uint8))
        self.imageResult = sharpened_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra sharpen sebagai Image object sementara
        sharpened_image.save("output_sharpen_temp.jpg")  # Simpan sementara

        # Menampilkan gambar sharpen di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_sharpen_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def gaussian_blur_3x3(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel Gaussian Blur 3x3
        kernel_gaussian_3x3 = np.array([[1, 2, 1], [2, 4, 2], [1, 2, 1]]) / 16

        # Menggunakan filter2D untuk menerapkan Gaussian Blur 3x3
        blurred_image_np = cv2.filter2D(image_np, -1, kernel_gaussian_3x3)

        # Mengubah array kembali ke gambar
        blurred_image = Image.fromarray(blurred_image_np.astype(np.uint8))
        self.imageResult = blurred_image

        # Menyimpan citra sementara
        blurred_image.save("output_gaussian_blur_3x3_temp.jpg")

        # Menampilkan gambar di kotak output
        pixmap = QtGui.QPixmap("output_gaussian_blur_3x3_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def gaussian_blur_5x5(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel Gaussian Blur 5x5
        kernel_gaussian_5x5 = np.array([[1, 4, 6, 4, 1],
                                        [4, 16, 24, 16, 4],
                                        [6, 24, 36, 24, 6],
                                        [4, 16, 24, 16, 4],
                                        [1, 4, 6, 4, 1]]) / 256

        # Menggunakan filter2D untuk menerapkan Gaussian Blur 5x5
        blurred_image_np = cv2.filter2D(image_np, -1, kernel_gaussian_5x5)

        # Mengubah array kembali ke gambar
        blurred_image = Image.fromarray(blurred_image_np.astype(np.uint8))
        self.imageResult = blurred_image

        # Menyimpan citra sementara
        blurred_image.save("output_gaussian_blur_5x5_temp.jpg")

        # Menampilkan gambar di kotak output
        pixmap = QtGui.QPixmap("output_gaussian_blur_5x5_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def unsharp_masking(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel Unsharp Masking
        kernel_unsharp = (-1/256) * np.array([[1, 4, 6, 4, 1],
                                            [4, 16, 24, 16, 4],
                                            [6, 24, -476, 24, 6],
                                            [4, 16, 24, 16, 4],
                                            [1, 4, 6, 4, 1]])

        # Menggunakan filter2D untuk menerapkan Unsharp Masking
        unsharp_image_np = cv2.filter2D(image_np, -1, kernel_unsharp)

        # Mengubah array kembali ke gambar
        unsharp_image = Image.fromarray(unsharp_image_np.astype(np.uint8))
        self.imageResult = unsharp_image

        # Menyimpan citra sementara
        unsharp_image.save("output_unsharp_masking_temp.jpg")

        # Menampilkan gambar di kotak output
        pixmap = QtGui.QPixmap("output_unsharp_masking_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def average_filter(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel Average Filter
        kernel_average = np.ones((5, 5), np.float32) / 25

        # Menggunakan filter2D untuk menerapkan Average Filter
        average_image_np = cv2.filter2D(image_np, -1, kernel_average)

        # Mengubah array kembali ke gambar
        average_image = Image.fromarray(average_image_np.astype(np.uint8))
        self.imageResult = average_image

        # Menyimpan citra sementara
        average_image.save("output_average_filter_temp.jpg")

        # Menampilkan gambar di kotak output
        pixmap = QtGui.QPixmap("output_average_filter_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def low_pass_filter(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel Low Pass Filter
        kernel_low_pass = np.ones((3, 3), np.float32) / 9

        # Menggunakan filter2D untuk menerapkan Low Pass Filter
        low_pass_image_np = cv2.filter2D(image_np, -1, kernel_low_pass)

        # Mengubah array kembali ke gambar
        low_pass_image = Image.fromarray(low_pass_image_np.astype(np.uint8))
        self.imageResult = low_pass_image

        # Menyimpan citra sementara
        low_pass_image.save("output_low_pass_filter_temp.jpg")

        # Menampilkan gambar di kotak output
        pixmap = QtGui.QPixmap("output_low_pass_filter_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def bandstop_filter(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Membuat kernel Band Stop Filter
        kernel_bandstop = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]) + np.ones((3, 3)) / 9

        # Menggunakan filter2D untuk menerapkan Band Stop Filter
        bandstop_image_np = cv2.filter2D(image_np, -1, kernel_bandstop)

        # Mengubah array kembali ke gambar
        bandstop_image = Image.fromarray(bandstop_image_np.astype(np.uint8))
        self.imageResult = bandstop_image

        # Menyimpan citra sementara
        bandstop_image.save("output_bandstop_filter_temp.jpg")

        # Menampilkan gambar di kotak output
        pixmap = QtGui.QPixmap("output_bandstop_filter_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())



    def extract_average_color(self):
        # Buat list untuk menyimpan hasil
        data = []

        # Ambil gambar dari self.imagefile (pastikan ini adalah objek gambar)
        img = self.imagefile  # Asumsikan self.imagefile berisi objek gambar

        # Jika Anda juga menyimpan nama file, pastikan untuk memiliki atribut untuk itu
        img_path = self.imagePath  # Misalnya, self.image_path menyimpan path asli dari gambar

        # Konversi gambar ke numpy array
        img_np = np.array(img)

        # Ekstraksi nilai rata-rata RGB
        avg_color_per_row = cv2.mean(img_np)[:3]  # Ambil 3 komponen pertama (R, G, B)
        R, G, B = avg_color_per_row

        # Tambahkan data ke list 
        data.append([1, os.path.basename(img_path), R, G, B])  # Menggunakan nama file yang dipilih

        # Buat DataFrame menggunakan pandas 
        new_data_df = pd.DataFrame(data, columns=['No', 'Nama', 'R', 'G', 'B'])

        output_path = 'output_ekstraksi.xlsx'

        # Cek apakah file sudah ada
        if os.path.exists(output_path):
            # Jika file sudah ada, baca file yang ada
            existing_df = pd.read_excel(output_path)

            # Gabungkan DataFrame yang ada dengan DataFrame baru
            combined_df = pd.concat([existing_df, new_data_df], ignore_index=True)
        else:
            # Jika tidak ada, gunakan DataFrame baru
            combined_df = new_data_df

        # Simpan hasil ke file excel
        combined_df.to_excel(output_path, index=False)

        print(f'Hasil ekstraksi telah disimpan di {output_path}')

        # Menyimpan hasil ke self untuk keperluan lain
        self.extractionResult = combined_df


    def extract_glcm_features(self, image_gray, angle):
        # Menghitung GLCM untuk sudut tertentu (0, 45, 90, 135 derajat)
        glcm = mt.features.haralick(image_gray)

        # Indeks untuk sudut yang sesuai
        angle_indices = {0: 0, 45: 1, 90: 2, 135: 3}
        glcm_at_angle = glcm[angle_indices[angle]]

        # Ekstraksi fitur yang diperlukan dari GLCM
        contrast = glcm_at_angle[1]  # Contrast
        homogeneity = glcm_at_angle[4]  # Homogeneity
        energy = glcm_at_angle[8]  # Energy
        correlation = glcm_at_angle[2]  # Correlation 

        return contrast, homogeneity, energy, correlation

    def extract_glcm_features_for_angles(self):
        # Buat list untuk menyimpan hasil
        data = []

        # Ambil gambar dari self.imagefile (pastikan ini adalah objek gambar)
        img = self.imagefile  # Asumsikan self.imagefile berisi objek gambar
        img_path = self.imagePath  # Misalnya, self.imagePath menyimpan path asli dari gambar

        # Konversi gambar ke grayscale 
        img_gray = cv2.cvtColor(np.array(img), cv2.COLOR_BGR2GRAY)

        # Daftar sudut untuk diiterasi
        angles = [0, 45, 90, 135]

        # Iterasi untuk setiap sudut
        for angle in angles:
            contrast, homogeneity, energy, correlation = self.extract_glcm_features(img_gray, angle)
            # Tambahkan data ke list
            data.append([angle, os.path.basename(img_path), contrast, homogeneity, energy, correlation])

        # Buat DataFrame menggunakan pandas 
        df = pd.DataFrame(data, columns=['Sudut', 'Nama Gambar', 'Contrast', 'Homogenitas', 'Energi', 'Korelasi'])

        output_path = 'output_Texture_Sudut_0_45_90_135.xlsx'

        # Cek apakah file sudah ada
        if os.path.exists(output_path):
            # Jika file sudah ada, baca file yang ada
            existing_df = pd.read_excel(output_path)

            # Gabungkan DataFrame yang ada dengan DataFrame baru
            combined_df = pd.concat([existing_df, df], ignore_index=True)
        else:
            # Jika tidak ada, gunakan DataFrame baru
            combined_df = df

        # Simpan hasil ke file excel
        combined_df.to_excel(output_path, index=False)

        print(f'Hasil ekstraksi fitur GLCM untuk sudut 0, 45, 90, dan 135 derajat telah disimpan di {output_path}')

        # Menyimpan hasil ke self untuk keperluan lain
        self.extractionResult = combined_df

    # def extract_glcm_0(self):
    #     self.extract_glcm_features_for_angles()

    # def extract_glcm_45(self):
    #     self.extract_glcm_features_for_angles()

    # def extract_glcm_90(self):
    #     self.extract_glcm_features_for_angles()

    # def extract_glcm_135(self):
    #     self.extract_glcm_features_for_angles()

    def apply_filter(self, image_np, filter_name):
        image_out = Image.fromarray(image_np.astype(np.uint8))
        self.imageResult = image_out

        # Save the image to a temporary file
        with tempfile.NamedTemporaryFile(suffix=".png", delete=False) as temp_file:
            temp_file_path = temp_file.name
            image_out.save(temp_file_path)

        # Load the image from the temporary file into QPixmap
        img_pixmap = QtGui.QPixmap(temp_file_path)

        # Get the size of the QGraphicsView
        view_width = self.graphicsView_2.width()
        view_height = self.graphicsView_2.height()

        # Scale the pixmap to fit the QGraphicsView, preserving the aspect ratio
        scaled_pixmap = img_pixmap.scaled(view_width, view_height, QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Clear any previous content in the scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

        # delete temp file
        os.remove(temp_file_path)

        print(f'{filter_name} filter applied successfully!')

    def filter_kuning(self):
        image_np = np.array(self.imagefile)

        # Apply yellow filter (increase red and green, remove blue)
        image_np[:, :, 2] = 0  # Remove blue component

        self.apply_filter(image_np, 'Yellow')

    def filter_orange(self):
        image_np = np.array(self.imagefile)

        # Apply orange filter (reduce blue component)
        image_np[:, :, 2] = image_np[:, :, 2] // 2  # Reduce blue component

        self.apply_filter(image_np, 'Orange')

    def filter_cyan(self):
        image_np = np.array(self.imagefile)

        # Apply cyan filter (remove red component)
        image_np[:, :, 0] = 0  # Remove red component

        self.apply_filter(image_np, 'Cyan')

    def filter_purple(self):
        image_np = np.array(self.imagefile)

        # Apply purple filter (remove green component)
        image_np[:, :, 1] = 0  # Remove green component

        self.apply_filter(image_np, 'Purple')

    def filter_grey(self):
        image_np = np.array(self.imagefile)

        # Convert to greyscale
        grey_image = np.mean(image_np, axis=2).astype(np.uint8)

        self.apply_filter(grey_image, 'Grey')

    def filter_coklat(self):
        image_np = np.array(self.imagefile)

        # Apply brown filter (adjust red, green, blue components)
        brown_filter = image_np.copy()
        brown_filter[:, :, 0] = brown_filter[:, :, 0] // 2  # Reduce blue
        brown_filter[:, :, 1] = brown_filter[:, :, 1] // 3  # Reduce green

        self.apply_filter(brown_filter, 'Brown')

    def filter_merah(self):
        image_np = np.array(self.imagefile)

        # Apply red filter (remove green and blue components)
        image_np[:, :, 0] = 0  # Remove blue component
        image_np[:, :, 1] = 0  # Remove green component

        self.apply_filter(image_np, 'Red')


    def gamma_correction(self, gamma=1.0):
        if gamma <= 0:
            raise ValueError("Gamma value must be greater than 0")
        
        # Membuka citra menggunakan PIL
        image = self.imagefile
        
        # Mengonversi citra ke numpy array
        image_np = np.array(image)
        
        # Melakukan gamma correction
        inv_gamma = 1.0 / gamma
        gamma_corrected_np = np.array(255 * (image_np / 255) ** inv_gamma, dtype='uint8')
        
        # Mengubah array kembali ke gambar
        gamma_corrected_image = Image.fromarray(gamma_corrected_np)
        self.imageResult = gamma_corrected_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra gamma correction sebagai Image object
        gamma_corrected_image.save("output_gamma_temp.jpg")  # Simpan sementara

        # Menampilkan gambar gamma correction di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_gamma_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())

    def applyRed(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Melakukan transformasi warna merah
        red_image_np = image_np.copy()
        red_image_np[:, :, 1] = 0  # Set green channel to 0
        red_image_np[:, :, 2] = 0  # Set blue channel to 0

        # Mengubah array kembali ke gambar
        red_image = Image.fromarray(red_image_np.astype(np.uint8))
        self.imageResult = red_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra merah sebagai Image object
        red_image.save("output_red_temp.jpg")  # Simpan sementara

        # Menampilkan gambar merah di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_red_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
        
        # self.labelOutput.setText('Effect : RGB - Red ')
        # self.showEffectComplete()

    def applyGreen(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Melakukan transformasi warna hijau
        green_image_np = image_np.copy()
        green_image_np[:, :, 0] = 0  # Set red channel to 0
        green_image_np[:, :, 2] = 0  # Set blue channel to 0

        # Mengubah array kembali ke gambar
        green_image = Image.fromarray(green_image_np.astype(np.uint8))
        self.imageResult = green_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra hijau sebagai Image object
        green_image.save("output_green_temp.jpg")  # Simpan sementara

        # Menampilkan gambar hijau di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_green_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
        
        # self.labelOutput.setText('Effect : RGB - Green ')
        # self.showEffectComplete()

    def applyBlue(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Melakukan transformasi warna biru
        blue_image_np = image_np.copy()
        blue_image_np[:, :, 0] = 0  # Set red channel to 0
        blue_image_np[:, :, 1] = 0  # Set green channel to 0

        # Mengubah array kembali ke gambar
        blue_image = Image.fromarray(blue_image_np.astype(np.uint8))
        self.imageResult = blue_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra biru sebagai Image object
        blue_image.save("output_blue_temp.jpg")  # Simpan sementara

        # Menampilkan gambar biru di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_blue_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
        
        # self.labelOutput.setText('Effect : RGB - Blue ')
        # self.showEffectComplete()

    def applyYellow(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Melakukan transformasi warna kuning
        yellow_image_np = image_np.copy()
        yellow_image_np[:, :, 2] = 0  # Set blue channel to 0

        # Mengubah array kembali ke gambar
        yellow_image = Image.fromarray(yellow_image_np.astype(np.uint8))
        self.imageResult = yellow_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra kuning sebagai Image object
        yellow_image.save("output_yellow_temp.jpg")  # Simpan sementara

        # Menampilkan gambar kuning di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_yellow_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
        
        # self.labelOutput.setText('Effect : RGB - Yellow ')
        # self.showEffectComplete()

    def applyOrange(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Melakukan transformasi warna jingga (red + green)
        orange_image_np = image_np.copy()
        orange_image_np[:, :, 0] = np.clip(orange_image_np[:, :, 0] + 50, 0, 255)  # Increase red
        orange_image_np[:, :, 1] = np.clip(orange_image_np[:, :, 1] - 50, 0, 255)  # Decrease green
        orange_image_np[:, :, 2] = 0  # Set blue channel to 0

        # Mengubah array kembali ke gambar
        orange_image = Image.fromarray(orange_image_np.astype(np.uint8))
        self.imageResult = orange_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra jingga sebagai Image object
        orange_image.save("output_orange_temp.jpg")  # Simpan sementara

        # Menampilkan gambar jingga di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_orange_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
        
        # self.labelOutput.setText('Effect : RGB - Orange ')
        # self.showEffectComplete()

    def applyCyan(self):
        # Membuka citra menggunakan PIL
        image = self.imagefile

        # Mengonversi citra ke numpy array
        image_np = np.array(image)

        # Melakukan transformasi warna cyan (G + B)
        cyan_image_np = image_np.copy()
        cyan_image_np[:, :, 0] = 0  # Set red channel to 0

        # Mengubah array kembali ke gambar
        cyan_image = Image.fromarray(cyan_image_np.astype(np.uint8))
        self.imageResult = cyan_image  # Simpan hasil untuk keperluan save

        # Menyimpan citra cyan sebagai Image object
        cyan_image.save("output_cyan_temp.jpg")  # Simpan sementara

        # Menampilkan gambar cyan di kotak output (Kotak2)
        pixmap = QtGui.QPixmap("output_cyan_temp.jpg")
        scaled_pixmap = pixmap.scaled(self.graphicsView_2.width(), self.graphicsView_2.height(), QtCore.Qt.KeepAspectRatio)

        self.sceneOutput.clear()  # Hapus konten sebelumnya di output scene
        self.sceneOutput.addPixmap(scaled_pixmap)
        self.graphicsView_2.setSceneRect(self.sceneOutput.itemsBoundingRect())
        
        # self.labelOutput.setText('Effect : RGB - Cyan ')
        # self.showEffectComplete()



#############################
    def setupUi(self, MainWindow):
        
        
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1500, 550)
        MainWindow.setFixedSize(1500, 550)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.graphicsView = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicsView.setGeometry(QtCore.QRect(10, 20, 581, 451))
        self.graphicsView.setObjectName("graphicsView")
        self.graphicsView_2 = QtWidgets.QGraphicsView(self.centralwidget)
        self.graphicsView_2.setGeometry(QtCore.QRect(611, 20, 581, 451))
        MainWindow.setCentralWidget(self.centralwidget)
        
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1070, 31))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        self.menuView = QtWidgets.QMenu(self.menubar)
        self.menuView.setObjectName("menuView")
        self.menuHistogram = QtWidgets.QMenu(self.menuView)
        self.menuHistogram.setObjectName("menuHistogram")
        self.menuColors = QtWidgets.QMenu(self.menubar)
        self.menuColors.setObjectName("menuColors")
        self.menuRGB = QtWidgets.QMenu(self.menuColors)
        self.menuRGB.setObjectName("menuRGB")
        self.menuRGB_to_Grayscale = QtWidgets.QMenu(self.menuColors)
        self.menuRGB_to_Grayscale.setObjectName("menuRGB_to_Grayscale")

        self.menuBrightness = QtWidgets.QMenu(self.menuColors)
        self.menuBrightness.setObjectName("menuBrightness")

        self.menuBit_Depth = QtWidgets.QMenu(self.menuColors)
        self.menuBit_Depth.setObjectName("menuBit_Depth")
        self.menuTentang = QtWidgets.QMenu(self.menubar)

        self.menuTransform = QtWidgets.QMenu(self.menubar)
        self.menuTransform.setObjectName("menuTransform")
        self.menuFlipping_2 = QtWidgets.QMenu(self.menuTransform)

        #aksi Crops
        
        self.menuCrops = QtWidgets.QMenu(self.menubar)
        self.menuCrops.setObjectName("menuCrops")
        
        self.actioncrops2 = QtWidgets.QAction(MainWindow)
        self.actioncrops2.setObjectName("actionCrops_")
        self.actioncrops2.triggered.connect(self.open_crop_dialog_region)

        self.actionTranslasi = QtWidgets.QAction(MainWindow)
        self.actionTranslasi.setObjectName("actionTranslasi")
        self.actionTranslasi.triggered.connect(self.open_translasi_dialog)

        self.actionRotasi = QtWidgets.QAction(MainWindow)
        self.actionRotasi.setObjectName("actionRotasi")
        self.actionRotasi.triggered.connect(self.open_rotation_dialog)

        self.actionHorizontal = QtWidgets.QAction(MainWindow)
        self.actionHorizontal.setObjectName("actionHorizontal")
        self.actionVertikal = QtWidgets.QAction(MainWindow)
        self.actionVertikal.setObjectName("actionVertikal")
        self.actionHorizontal_2 = QtWidgets.QAction(MainWindow)
        self.actionHorizontal_2.setObjectName("actionHorizontal_2")
        self.actionHorizontal_2.triggered.connect(self.flip_image_horzontal)

        self.actionVertikal_2 = QtWidgets.QAction(MainWindow)
        self.actionVertikal_2.setObjectName("actionVertikal_2")
        self.actionVertikal_2.triggered.connect(self.flip_image_vertikal)

        self.actionZoom = QtWidgets.QAction(MainWindow)
        self.actionZoom.setObjectName("actionZoom")
        self.actionZoom.triggered.connect(self.open_zoom_dialog)

        self.menuCrops.addAction(self.actioncrops2)
        
        

        self.menuFlipping_2.addAction(self.actionHorizontal_2)
        self.menuFlipping_2.addAction(self.actionVertikal_2)
        self.menuTransform.addAction(self.actionTranslasi)
        self.menuTransform.addAction(self.actionRotasi)
        self.menuTransform.addAction(self.menuFlipping_2.menuAction())
        self.menuTransform.addAction(self.actionZoom)
        
        self.menuTentang.setObjectName("menuTentang")
        
        self.actionTentang = QtWidgets.QAction(MainWindow)
        self.actionTentang.setObjectName("actionTentang")
        self.actionTentang.triggered.connect(self.TentangFrame)

        self.menuImage_Processing = QtWidgets.QMenu(self.menubar)
        self.menuImage_Processing.setObjectName("menuImage_Processing")
        self.menuAritmetical_Operation = QtWidgets.QMenu(self.menubar)
        self.menuAritmetical_Operation.setObjectName("menuAritmetical_Operation")
        self.menuFilter = QtWidgets.QMenu(self.menubar)
        self.menuFilter.setObjectName("menuFilter")
        self.menuEdge_Detection = QtWidgets.QMenu(self.menuFilter)
        self.menuEdge_Detection.setObjectName("menuEdge_Detection")
        self.menuGaussian_Blur = QtWidgets.QMenu(self.menuFilter)
        self.menuGaussian_Blur.setObjectName("menuGaussian_Blur")
        self.menuEdge_Detection_2 = QtWidgets.QMenu(self.menubar)
        self.menuEdge_Detection_2.setObjectName("menuEdge_Detection_2")
        self.menuMorfologi = QtWidgets.QMenu(self.menubar)
        self.menuMorfologi.setObjectName("menuMorfologi")
        self.menuErosion = QtWidgets.QMenu(self.menuMorfologi)
        self.menuErosion.setObjectName("menuErosion")
        self.menuDilation = QtWidgets.QMenu(self.menuMorfologi)
        self.menuDilation.setObjectName("menuDilation")
        self.menuOpening = QtWidgets.QMenu(self.menuMorfologi)
        self.menuOpening.setObjectName("menuOpening")
        self.menuClosing = QtWidgets.QMenu(self.menuMorfologi)
        self.menuClosing.setObjectName("menuClosing")

        # set menu Hit or Miss
        self.menuHitormiss = QtWidgets.QAction(self.menuMorfologi)
        self.menuHitormiss.setObjectName("menuHitormiss")
        self.menuHitormiss.triggered.connect(self.hit_or_miss)

        # set menu Thinning
        self.menuThinning = QtWidgets.QAction(self.menuMorfologi)
        self.menuThinning.setObjectName("menuThinning")
        self.menuThinning.triggered.connect(self.thinning)

        # set menu Thickening
        self.menuThickening = QtWidgets.QAction(self.menuMorfologi)
        self.menuThickening.setObjectName("menuThickening")
        self.menuThickening.triggered.connect(self.thickening)

        #set fungsi skeletonization
        self.menuSkeletonization = QtWidgets.QAction(self.menuMorfologi)
        self.menuSkeletonization.setObjectName("menuSkeletonization")
        self.menuSkeletonization.triggered.connect(self.skeletonization)

        # set fungsi prunning
        self.menuPrunning = QtWidgets.QAction(self.menuMorfologi)
        self.menuPrunning.setObjectName("menuPrunning")
        self.menuPrunning.triggered.connect(self.prune_skeleton)



        
        self.menuClear = QtWidgets.QMenu(self.menubar)
        self.menuClear.setObjectName("menuClear")

        # self.actionclear = QtWidgets.QAction(MainWindow)
        # self.actionclear.setObjectName("clearaction")
        # self.actionclear.triggered.connect(self.clear_images)
        
        # self.actionclear.triggered.connect(self.clear_images)

        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.actionOpen = QtWidgets.QAction(MainWindow)


        #Aksi Untuk Open File
        self.actionOpen.setIconVisibleInMenu(True)
        self.actionOpen.setObjectName("actionOpen")
        self.actionOpen.triggered.connect(self.openImage)

        #menampilkan gambar di Kotak1 menggunakan grapich
        self.scene = QGraphicsScene()
        self.graphicsView.setScene(self.scene)

        #menampilkan gambar di Kotak2(output) menggunakan grapich
        self.sceneOutput = QGraphicsScene()
        self.graphicsView_2.setScene(self.sceneOutput) 

        #Fungsi Save As
        self.actionSave_As = QtWidgets.QAction(MainWindow)
        self.actionSave_As.setObjectName("actionSave_As")
        self.actionSave_As.triggered.connect(self.saveAs)

        #Fungsi Exit
        self.actionExit = QtWidgets.QAction(MainWindow)
        self.actionExit.setObjectName("actionExit") 
        self.actionExit.triggered.connect(QApplication.quit)

        #input histogram 
        self.actionInput = QtWidgets.QAction(MainWindow)
        self.actionInput.setObjectName("actionInput")
        self.actionInput.triggered.connect(self.tampilkan_histogram_citra_input)

        #output histogram 
        self.actionOutput = QtWidgets.QAction(MainWindow)
        self.actionOutput.setObjectName("actionOutput")
        self.actionOutput.triggered.connect(self.tampilkan_histogram_citra_output)
        

        self.actionInput_Output = QtWidgets.QAction(MainWindow)
        self.actionInput_Output.setObjectName("actionInput_Output")
        self.actionInput_Output.triggered.connect(self.tampilkan_histogram_citra_inputoutput)

        # self.actionBrightness = QtWidgets.QAction(MainWindow)
        # self.actionBrightness.setObjectName("actionBrightness")

        # Set actionBrightnessandContrast.
        self.actionBrightnessandContrast = QtWidgets.QAction(MainWindow)
        self.actionBrightnessandContrast.setObjectName("actionBrightnessandContrass")
        self.actionBrightnessandContrast.triggered.connect(self.open_linear_contrast_brightness_dialog)

        #aksiclear
        self.actionKuantitas = QtWidgets.QAction(MainWindow)
        self.actionKuantitas.setObjectName("actionKuantitas")
        self.actionKuantitas.triggered.connect(self.grayscale_quantization)

        self.actionClear = QtWidgets.QAction(MainWindow)
        self.actionClear.setObjectName("actionClear")
        self.actionClear.triggered.connect(self.clear_images)

        self.actionOperasiAritmatika = QtWidgets.QAction(MainWindow)
        self.actionOperasiAritmatika.setObjectName("actionOperasiAritmatika")
        self.actionOperasiAritmatika.triggered.connect(self.show_aritmatika_window)
        
        #set Invers
        self.actionInvers = QtWidgets.QAction(MainWindow)
        self.actionInvers.setObjectName("actionInvers")
        self.actionInvers.triggered.connect(self.inverse) 

        self.actionLog_Brigthness = QtWidgets.QAction(MainWindow)
        self.actionLog_Brigthness.setObjectName("actionLog_Brigthness")
        self.actionLog_Brigthness.triggered.connect(self.open_log_brightness_dialog)

        self.actionGamma_Correstion = QtWidgets.QAction(MainWindow)
        self.actionGamma_Correstion.setObjectName("actionGamma_Correstion")
        self.actionGamma_Correstion.triggered.connect(lambda: self.gamma_correction(gamma=2.0))
        
        # set fungsi Kuning
        self.actionKuning = QtWidgets.QAction(MainWindow)
        self.actionKuning.setObjectName("actionKuning")
        self.actionKuning.triggered.connect(self.applyYellow)

        # set fungsi Orange
        self.actionOrange = QtWidgets.QAction(MainWindow)
        self.actionOrange.setObjectName("actionOrange")
        self.actionOrange.triggered.connect(self.filter_orange)

        # set fungsi Cyan 
        self.actionCyan = QtWidgets.QAction(MainWindow)
        self.actionCyan.setObjectName("actionCyan")
        self.actionCyan.triggered.connect(self.applyCyan)

        # set fungsi Purple
        self.actionPurple = QtWidgets.QAction(MainWindow)
        self.actionPurple.setObjectName("actionPurple")
        self.actionPurple.triggered.connect(self.filter_purple)

        # set fungsi Gray
        self.actionGrey = QtWidgets.QAction(MainWindow)
        self.actionGrey.setObjectName("actionGrey")
        self.actionGrey.triggered.connect(self.filter_grey)

        # set fungsi coklat
        self.actionCoklat = QtWidgets.QAction(MainWindow)
        self.actionCoklat.setObjectName("actionCoklat")
        self.actionCoklat.triggered.connect(self.filter_coklat)

        #set Grayscale_Average
        self.actionAverage = QtWidgets.QAction(MainWindow)
        self.actionAverage.setObjectName("actionAverage")
        self.actionAverage.triggered.connect(self.grayscale_average) 

        #set Grayscale_Average
        self.actionLightness = QtWidgets.QAction(MainWindow)
        self.actionLightness.setObjectName("actionLightness")
        self.actionLightness.triggered.connect(self.grayscale_lightness) 

        #set Grayscale_luminance
        self.actionLuminance = QtWidgets.QAction(MainWindow)
        self.actionLuminance.setObjectName("actionLuminance")
        self.actionLuminance.triggered.connect(self.grayscale_luminance)

        self.actionBrightness = QtWidgets.QAction(MainWindow)
        self.actionBrightness.setObjectName("actionBrightness")
        self.actionBrightness.triggered.connect(self.open_linear_brightness_dialog) 

        self.actionContrast = QtWidgets.QAction(MainWindow)
        self.actionContrast.setObjectName("actionContrast")
        self.actionContrast.triggered.connect(self.open_linear_contrast_dialog)

        self.actionSaturation = QtWidgets.QAction(MainWindow)
        self.actionSaturation.setObjectName("actionSaturation")
        self.actionSaturation.triggered.connect(self.open_linear_saturation_dialog) 



        self.action1_bit = QtWidgets.QAction(MainWindow)
        self.action1_bit.setObjectName("action1_bit")
        self.action1_bit.triggered.connect(self.grayscale_quantization_1)

        self.action2_bit = QtWidgets.QAction(MainWindow)
        self.action2_bit.setObjectName("action2_bit")
        self.action2_bit.triggered.connect(self.grayscale_quantization_2)

        self.action3_bit = QtWidgets.QAction(MainWindow)
        self.action3_bit.setObjectName("action3_bit")
        self.action3_bit.triggered.connect(self.grayscale_quantization_3)

        self.action4_bit = QtWidgets.QAction(MainWindow)
        self.action4_bit.setObjectName("action4_bit")
        self.action4_bit.triggered.connect(self.grayscale_quantization_4)

        self.action5_bit = QtWidgets.QAction(MainWindow)
        self.action5_bit.setObjectName("action5_bit")
        self.action5_bit.triggered.connect(self.grayscale_quantization_5)

        self.action6_bit = QtWidgets.QAction(MainWindow)
        self.action6_bit.setObjectName("action6_bit")
        self.action6_bit.triggered.connect(self.grayscale_quantization_6)

        self.action7_bit = QtWidgets.QAction(MainWindow)
        self.action7_bit.setObjectName("action7_bit")
        self.action7_bit.triggered.connect(self.grayscale_quantization_7)

        #set actionHistogram_image
        self.actionHistogram_image = QtWidgets.QAction(MainWindow)
        self.actionHistogram_image.setObjectName("actionHistogram_image")
        self.actionHistogram_image.triggered.connect(self.tampilkan_histogram_citra)

        #set actionHistogram_Equalization
        self.actionHistogram_Equalization = QtWidgets.QAction(MainWindow)
        self.actionHistogram_Equalization.setObjectName("actionHistogram_Equalization")
        self.actionHistogram_Equalization.triggered.connect(self.histogram_equalization)

        #set  actionFuzzyHistogram_Equalization
        self.actionFuzzyHistogram_Equalization = QtWidgets.QAction(MainWindow)
        self.actionFuzzyHistogram_Equalization.setObjectName("actionHFuzzyistogram_Equalization")
        self.actionFuzzyHistogram_Equalization.triggered.connect(self.fuzzy_histogram_equalization)

        self.actionFuzzy_HE_RGB = QtWidgets.QAction(MainWindow)
        self.actionFuzzy_HE_RGB.setObjectName("actionFuzzy_HE_RGB")
        self.actionFuzzy_HE_RGB.triggered.connect(self.fhe_rgb)


        self.menuSegmentasi = QtWidgets.QMenu(self.menubar)
        self.menuSegmentasi.setObjectName("menuSegmentasi")
        # MainWindow.setMenuBar(self.menubar)
        # self.statusbar = QtWidgets.QStatusBar(MainWindow)
        # self.statusbar.setObjectName("statusbar")
        # MainWindow.setStatusBar(self.statusbar)

        #set fungsi region growing 
        self.actionRegion_Growing = QtWidgets.QAction(MainWindow)
        self.actionRegion_Growing.setObjectName("actionRegion_Growing")
        self.actionRegion_Growing.triggered.connect(self.regionGrowing)

        #set fungsi k means clustering 
        self.actionK_Means_Clustering = QtWidgets.QAction(MainWindow)
        self.actionK_Means_Clustering.setObjectName("actionK_Means_Clustering")
        self.actionK_Means_Clustering.triggered.connect(self.kmeansClustering)

        #set fungsi watershed
        self.actionWatershed = QtWidgets.QAction(MainWindow)
        self.actionWatershed.setObjectName("actionWatershed")
        self.actionWatershed.triggered.connect(self.watershedSegmentation)

        #set fungsi global thresholding
        self.actionGlobal_Thresholding = QtWidgets.QAction(MainWindow)
        self.actionGlobal_Thresholding.setObjectName("actionGlobal_Thresholding")
        self.actionGlobal_Thresholding.triggered.connect(self.globalThresholding)

        #set fungsi adaptive thresholding
        self.actionAdaptive_Thresholding = QtWidgets.QAction(MainWindow)
        self.actionAdaptive_Thresholding.setObjectName("actionAdaptive_Thresholding")
        self.actionAdaptive_Thresholding.triggered.connect(self.adaptive_thesholding)

        #set fungsi adaptive actionAdaptive_ThreshMean
        self.actionAdaptive_ThreshMean = QtWidgets.QAction(MainWindow)
        self.actionAdaptive_ThreshMean.setObjectName("actionAdaptive_ThreshMean")
        self.actionAdaptive_ThreshMean.triggered.connect(self.segment_adaptive_thresh_mean)

        #set fungsi adaptive actionAdaptive_ThreshGaussian
        self.actionAdaptive_ThreshGaussian = QtWidgets.QAction(MainWindow)
        self.actionAdaptive_ThreshGaussian.setObjectName("actionAdaptive_ThreshGaussian")
        self.actionAdaptive_ThreshGaussian.triggered.connect(self.segment_adaptive_thresh_gaussian)


        self.menuSegmentasi.addAction(self.actionRegion_Growing)
        self.menuSegmentasi.addAction(self.actionK_Means_Clustering)
        self.menuSegmentasi.addAction(self.actionWatershed)
        self.menuSegmentasi.addAction(self.actionGlobal_Thresholding)
        self.menuSegmentasi.addAction(self.actionAdaptive_Thresholding)
        self.menuSegmentasi.addAction(self.actionAdaptive_ThreshMean)
        self.menuSegmentasi.addAction(self.actionAdaptive_ThreshGaussian)
       
        # set fungsi identity
        self.actionIdentity = QtWidgets.QAction(MainWindow)
        self.actionIdentity.setObjectName("actionIdentity")
        self.actionIdentity.triggered.connect(self.identity)

        # set fungsi sharpen 
        self.actionSharpen = QtWidgets.QAction(MainWindow)
        self.actionSharpen.setObjectName("actionSharpen")
        self.actionSharpen.triggered.connect(self.sharpen)

        # set fungsi actionUnsharp_Masking
        self.actionUnsharp_Masking = QtWidgets.QAction(MainWindow)
        self.actionUnsharp_Masking.setObjectName("actionUnsharp_Masking")
        self.actionUnsharp_Masking.triggered.connect(self.unsharp_masking)

        # set fungsi actionAverage_Filter
        self.actionAverage_Filter = QtWidgets.QAction(MainWindow)
        self.actionAverage_Filter.setObjectName("actionAverage_Filter")
        self.actionAverage_Filter.triggered.connect(self.average_filter)

        # self fungsi actionLow_Pass_Filter
        self.actionLow_Pass_Filter = QtWidgets.QAction(MainWindow)
        self.actionLow_Pass_Filter.setObjectName("actionLow_Pass_Filter")
        self.actionLow_Pass_Filter.triggered.connect(self.low_pass_filter)

        # set fungsi actionBandstop_Filter
        self.actionBandstop_Filter = QtWidgets.QAction(MainWindow)
        self.actionBandstop_Filter.setObjectName("actionBandstop_Filter")
        self.actionBandstop_Filter.triggered.connect(self.bandstop_filter)

        # set fungsi edge detection 1
        self.actionEdge_Detection_1 = QtWidgets.QAction(MainWindow)
        self.actionEdge_Detection_1.setObjectName("actionEdge_Detection_1")
        self.actionEdge_Detection_1.triggered.connect(self.edge_detection_1)

        # set fungsi edge detection 2
        self.actionEdge_Detection_2 = QtWidgets.QAction(MainWindow)
        self.actionEdge_Detection_2.setObjectName("actionEdge_Detection_2")
        self.actionEdge_Detection_2.triggered.connect(self.edge_detection_2)

        # set edge detection 3
        self.actionEdge_Detection_3 = QtWidgets.QAction(MainWindow)
        self.actionEdge_Detection_3.setObjectName("actionEdge_Detection_3")
        self.actionEdge_Detection_3.triggered.connect(self.edge_detection_3)

        # set fungsi gaussian_blur_3x3
        self.actionGaussian_Blur_3x3 = QtWidgets.QAction(MainWindow)
        self.actionGaussian_Blur_3x3.setObjectName("actionGaussian_Blur_3x3")
        self.actionGaussian_Blur_3x3.triggered.connect(self.gaussian_blur_3x3)

        # set fungsi ussian_blur_5x5
        self.actionGaussian_Blur_5x5 = QtWidgets.QAction(MainWindow)
        self.actionGaussian_Blur_5x5.setObjectName("actionGaussian_Blur_5x5")
        self.actionGaussian_Blur_5x5.triggered.connect(self.gaussian_blur_5x5)

        # set fungsi prewitt
        self.actionPrewitt = QtWidgets.QAction(MainWindow)
        self.actionPrewitt.setObjectName("actionPrewitt")
        self.actionPrewitt.triggered.connect(self.prewitt)

        #set fungsi sobel
        self.actionSobel = QtWidgets.QAction(MainWindow)
        self.actionSobel.setObjectName("actionSobel")
        self.actionSobel.triggered.connect(self.sobel)

        self.actionCanny = QtWidgets.QAction(MainWindow)
        self.actionCanny.setObjectName("actionCanny")
        self.actionCanny.triggered.connect(self.canny)

        # set Erosi Square 3
        self.actionSquare_3 = QtWidgets.QAction(MainWindow)
        self.actionSquare_3.setObjectName("actionSquare_3")
        self.actionSquare_3.triggered.connect(self.erosion_square_3)

        # set Erosi Square 5
        self.actionSquare_5 = QtWidgets.QAction(MainWindow)
        self.actionSquare_5.setObjectName("actionSquare_5")
        self.actionSquare_5.triggered.connect(self.erosion_square_5)

        # set fungsi Cross 3
        self.actionCross_3 = QtWidgets.QAction(MainWindow)
        self.actionCross_3.setObjectName("actionCross_3")
        self.actionCross_3.triggered.connect(self.erosion_cross_3)

        # set fungsi Dilasi square 3
        self.actionSquare_4 = QtWidgets.QAction(MainWindow)
        self.actionSquare_4.setObjectName("actionSquare_4")
        self.actionSquare_4.triggered.connect(self.dilation_square_3)

        # set fungsi Dilasi square 5
        self.actionSquare_6 = QtWidgets.QAction(MainWindow)
        self.actionSquare_6.setObjectName("actionSquare_6")
        self.actionSquare_6.triggered.connect(self.dilation_square_5)

        # set fungsi Dilasi Cross 3
        self.actionCross_4 = QtWidgets.QAction(MainWindow)
        self.actionCross_4.setObjectName("actionCross_4")
        self.actionCross_4.triggered.connect(self.dilation_cross_3)

        # set fungsi Opening Square 9
        self.actionSquare_9 = QtWidgets.QAction(MainWindow)
        self.actionSquare_9.setObjectName("actionSquare_9")
        self.actionSquare_9.triggered.connect(self.opening_square_9)

        # set fungsi Clossing square 9
        self.actionSquare_10 = QtWidgets.QAction(MainWindow)
        self.actionSquare_10.setObjectName("actionSquare_10")
        self.actionSquare_10.triggered.connect(self.closing_square_9)

# Extraksi
        self.menuExtraction = QtWidgets.QMenu(self.menubar)
        self.menuExtraction.setObjectName("menuExtraction")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)

        #set fungsi Esktraksi RGB
        self.actionRGB = QtWidgets.QAction(MainWindow)
        self.actionRGB.setObjectName("actionRGB")
        self.actionRGB.triggered.connect(self.extract_average_color)

        # Set fungsi Ekstraksi GLCM
        self.actionGLCM = QtWidgets.QAction(MainWindow)
        self.actionGLCM.setObjectName("actionGLCM")
        self.actionGLCM.triggered.connect(self.extract_glcm_features_for_angles)
        self.menuExtraction.addAction(self.actionRGB)
        self.menuExtraction.addAction(self.actionGLCM)
        

        # set fungsi Extraksti RGB
        # self.actionRGB = QtWidgets.QAction(MainWindow)
        # self.actionRGB.setObjectName("actionRGB")
        # self.actionRGB.triggered.connect(self.extract_average_color)

        # # set Actin 0 
        # self.action0_Derajat = QtWidgets.QAction(MainWindow)
        # self.action0_Derajat.setObjectName("action0_Derajat")
        # self.action0_Derajat.triggered.connect(self.extract_glcm_0)

        
      
        

        self.menuFile.addAction(self.actionOpen)
        self.menuFile.addAction(self.actionSave_As)
        self.menuFile.addAction(self.actionExit)
        self.menuHistogram.addSeparator()
        self.menuHistogram.addAction(self.actionInput)
        self.menuHistogram.addAction(self.actionOutput)
        self.menuHistogram.addAction(self.actionInput_Output)
        self.menuView.addAction(self.menuHistogram.menuAction())
        self.menuRGB.addAction(self.actionKuning)
        self.menuRGB.addAction(self.actionOrange)
        self.menuRGB.addAction(self.actionCyan)
        self.menuRGB.addAction(self.actionPurple)
        self.menuRGB.addAction(self.actionGrey)
        self.menuRGB.addAction(self.actionCoklat)
        self.menuRGB_to_Grayscale.addAction(self.actionAverage)
        self.menuRGB_to_Grayscale.addAction(self.actionLightness)
        self.menuRGB_to_Grayscale.addAction(self.actionLuminance)
        self.menuBrightness.addAction(self.actionBrightness)
        self.menuBrightness.addAction(self.actionContrast)
        self.menuBrightness.addAction(self.actionSaturation)
        self.menuBit_Depth.addAction(self.action1_bit)
        self.menuBit_Depth.addAction(self.action2_bit)
        self.menuBit_Depth.addAction(self.action3_bit)
        self.menuBit_Depth.addAction(self.action4_bit)
        self.menuBit_Depth.addAction(self.action5_bit)
        self.menuBit_Depth.addAction(self.action6_bit)
        self.menuBit_Depth.addAction(self.action7_bit)
        self.menuColors.addAction(self.menuRGB.menuAction())
        self.menuColors.addAction(self.menuRGB_to_Grayscale.menuAction())
        self.menuColors.addAction(self.menuBrightness.menuAction())
        self.menuColors.addAction(self.actionBrightnessandContrast)
        self.menuColors.addAction(self.actionKuantitas)
        self.menuClear.addAction(self.actionClear)
        self.menuTentang.addAction(self.actionTentang)
        self.menuAritmetical_Operation.addAction(self.actionOperasiAritmatika)

        
        
        self.menuColors.addAction(self.actionInvers)
        self.menuColors.addAction(self.actionLog_Brigthness)
        self.menuColors.addAction(self.menuBit_Depth.menuAction())
        self.menuColors.addAction(self.actionGamma_Correstion)
        self.menuImage_Processing.addAction(self.actionHistogram_image)
        self.menuImage_Processing.addAction(self.actionHistogram_Equalization)
        self.menuImage_Processing.addAction(self.actionFuzzyHistogram_Equalization)
        self.menuImage_Processing.addAction(self.actionFuzzy_HE_RGB)
        self.menuEdge_Detection.addAction(self.actionEdge_Detection_1)
        self.menuEdge_Detection.addAction(self.actionEdge_Detection_2)
        self.menuEdge_Detection.addAction(self.actionEdge_Detection_3)
        self.menuGaussian_Blur.addAction(self.actionGaussian_Blur_3x3)
        self.menuGaussian_Blur.addAction(self.actionGaussian_Blur_5x5)
        self.menuFilter.addAction(self.actionIdentity)
        self.menuFilter.addAction(self.menuEdge_Detection.menuAction())
        self.menuFilter.addAction(self.actionSharpen)
        self.menuFilter.addAction(self.menuGaussian_Blur.menuAction())
        self.menuFilter.addAction(self.actionUnsharp_Masking)
        self.menuFilter.addAction(self.actionAverage_Filter)
        self.menuFilter.addAction(self.actionLow_Pass_Filter)
        self.menuFilter.addAction(self.actionBandstop_Filter)
        self.menuEdge_Detection_2.addAction(self.actionPrewitt)
        self.menuEdge_Detection_2.addAction(self.actionSobel)
        self.menuEdge_Detection_2.addAction(self.actionCanny)
        self.menuErosion.addAction(self.actionSquare_3)
        self.menuErosion.addAction(self.actionSquare_5)
        self.menuErosion.addAction(self.actionCross_3)
        self.menuDilation.addAction(self.actionSquare_4)
        self.menuDilation.addAction(self.actionSquare_6)
        self.menuDilation.addAction(self.actionCross_4)
        self.menuOpening.addAction(self.actionSquare_9)
        self.menuClosing.addAction(self.actionSquare_10)
        self.menuMorfologi.addAction(self.menuErosion.menuAction())
        self.menuMorfologi.addAction(self.menuDilation.menuAction())
        self.menuMorfologi.addAction(self.menuOpening.menuAction())
        self.menuMorfologi.addAction(self.menuClosing.menuAction())

        self.menuMorfologi.addAction(self.menuHitormiss)
        self.menuMorfologi.addAction(self.menuThinning)
        self.menuMorfologi.addAction(self.menuThickening)
        self.menuMorfologi.addAction(self.menuSkeletonization)
        self.menuMorfologi.addAction(self.menuPrunning)

        
        # self.menuExtraction.addAction(self.actionRGB)
        # self.menuExtraction.addAction(self.menuGLCM.menuAction())
        


        self.menubar.addAction(self.menuFile.menuAction())
        self.menubar.addAction(self.menuView.menuAction())
        self.menubar.addAction(self.menuColors.menuAction())
        self.menubar.addAction(self.menuTransform.menuAction())
        self.menubar.addAction(self.menuCrops.menuAction())
        self.menubar.addAction(self.menuTentang.menuAction())
        self.menubar.addAction(self.menuImage_Processing.menuAction())
        self.menubar.addAction(self.menuSegmentasi.menuAction())
        self.menubar.addAction(self.menuAritmetical_Operation.menuAction())
        self.menubar.addAction(self.menuFilter.menuAction())
        self.menubar.addAction(self.menuEdge_Detection_2.menuAction())
        self.menubar.addAction(self.menuMorfologi.menuAction())
        self.menubar.addAction(self.menuExtraction.menuAction())

        self.menubar.addAction(self.menuExtraction.menuAction())
        self.menubar.addAction(self.menuClear.menuAction())
        

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Image Processing"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.menuView.setTitle(_translate("MainWindow", "View"))
        self.menuHistogram.setTitle(_translate("MainWindow", "Histogram"))
        self.menuColors.setTitle(_translate("MainWindow", "Colors"))
        self.menuTransform.setTitle(_translate("MainWindow", "Transform"))

        self.menuSegmentasi.setTitle(_translate("MainWindow", "Segmentasi"))
        self.actionRegion_Growing.setText(_translate("MainWindow", "Region Growing"))
        self.actionK_Means_Clustering.setText(_translate("MainWindow", "K-Means Clustering"))
        self.actionWatershed.setText(_translate("MainWindow", "Watershed"))
        self.actionGlobal_Thresholding.setText(_translate("MainWindow", "Global Thresholding"))
        self.actionAdaptive_Thresholding.setText(_translate("MainWindow", "Adaptive Thresholding"))
        self.actionAdaptive_ThreshMean.setText(_translate("MainWindow", "Adaptive Thresh Mean"))
        self.actionAdaptive_ThreshGaussian.setText(_translate("MainWindow", "Adaptive Thresh Gaussian"))

        self.menuTransform.setTitle(_translate("MainWindow", "Transform"))
        self.menuFlipping_2.setTitle(_translate("MainWindow", "Flipping"))
        self.menuCrops.setTitle(_translate("MainWindow", "Crops"))
        self.actioncrops2.setText(_translate("MainWindow", "Crops"))
        self.actionTranslasi.setText(_translate("MainWindow", "Translasi"))
        self.actionRotasi.setText(_translate("MainWindow", "Rotasi"))
        self.actionHorizontal.setText(_translate("MainWindow", "Horizontal"))
        self.actionVertikal.setText(_translate("MainWindow", "Vertikal"))
        self.actionHorizontal_2.setText(_translate("MainWindow", "Horizontal"))
        self.actionVertikal_2.setText(_translate("MainWindow", "Vertikal"))
        self.actionZoom.setText(_translate("MainWindow", "Zoom"))
        self.menuRGB.setTitle(_translate("MainWindow", "RGB"))
        self.menuRGB_to_Grayscale.setTitle(_translate("MainWindow", "RGB to Grayscale"))
        self.menuBrightness.setTitle(_translate("MainWindow", "Brightness"))
        self.menuBit_Depth.setTitle(_translate("MainWindow", "Bit Depth"))
        self.menuTentang.setTitle(_translate("MainWindow", "Tentang"))
        self.actionTentang.setText(_translate("MainWindow", "Tentang"))
        self.menuImage_Processing.setTitle(_translate("MainWindow", "Image Processing"))
        self.menuAritmetical_Operation.setTitle(_translate("MainWindow", "Aritmetical Operation"))
        self.actionOperasiAritmatika.setText(_translate("MainWindow", "Aritmetical Operation"))
        self.menuFilter.setTitle(_translate("MainWindow", "Filter"))
        self.menuEdge_Detection.setTitle(_translate("MainWindow", "Edge Detection"))
        self.menuGaussian_Blur.setTitle(_translate("MainWindow", "Gaussian Blur"))
        self.menuEdge_Detection_2.setTitle(_translate("MainWindow", "Edge Detection "))
        self.menuMorfologi.setTitle(_translate("MainWindow", "Morfologi"))
        self.menuErosion.setTitle(_translate("MainWindow", "Erosion"))
        self.menuDilation.setTitle(_translate("MainWindow", "Dilation"))
        self.menuOpening.setTitle(_translate("MainWindow", "Opening"))
        self.menuClosing.setTitle(_translate("MainWindow", "Closing"))
        self.menuHitormiss.setText(_translate("MainWindow", "Hit-or-Miss"))
        self.menuThinning.setText(_translate("MainWindow", "Thinning"))
        self.menuThickening.setText(_translate("MainWindow", "Thickening"))
        self.menuSkeletonization.setText(_translate("MainWindow", "Skeletonization"))
        self.menuPrunning.setText(_translate("MainWindow", "Prunning"))


        self.menuClear.setTitle(_translate("MainWindow", "Clear"))
        self.actionClear.setText(_translate("MainWindow", "Clear"))
        self.actionOpen.setText(_translate("MainWindow", "Open"))
        self.actionSave_As.setText(_translate("MainWindow", "Save As"))
        self.actionExit.setText(_translate("MainWindow", "Exit"))
        self.actionInput.setText(_translate("MainWindow", "Input"))
        self.actionOutput.setText(_translate("MainWindow", "Output"))
        self.actionInput_Output.setText(_translate("MainWindow", "Input Output"))
        # self.menuBrightness.setText(_translate("MainWindow", "Brightness"))
        self.actionBrightnessandContrast.setText(_translate("MainWindow", "Brightness and Contrast"))
        
        self.actionKuantitas.setText(_translate("MainWindow", "Kuantitas"))
        self.actionInvers.setText(_translate("MainWindow", "Invers"))
        self.actionLog_Brigthness.setText(_translate("MainWindow", "Log Brigthness"))
        self.actionGamma_Correstion.setText(_translate("MainWindow", "Gamma Correstion"))
        self.actionKuning.setText(_translate("MainWindow", "Kuning"))
        self.actionOrange.setText(_translate("MainWindow", "Orange"))
        self.actionCyan.setText(_translate("MainWindow", "Cyan"))
        self.actionPurple.setText(_translate("MainWindow", "Purple"))
        self.actionGrey.setText(_translate("MainWindow", "Grey"))
        self.actionCoklat.setText(_translate("MainWindow", "Coklat"))
        self.actionAverage.setText(_translate("MainWindow", "Average"))
        self.actionLightness.setText(_translate("MainWindow", "Lightness"))
        self.actionLuminance.setText(_translate("MainWindow", "Luminance"))
        self.actionBrightness.setText(_translate("MainWindow", "Brightness"))
        self.actionContrast.setText(_translate("MainWindow", "Contrast"))
        self.actionSaturation.setText(_translate("MainWindow", "Saturation"))
        self.action1_bit.setText(_translate("MainWindow", "1 bit"))
        self.action2_bit.setText(_translate("MainWindow", "2 bit"))
        self.action3_bit.setText(_translate("MainWindow", "3 bit"))
        self.action4_bit.setText(_translate("MainWindow", "4 bit"))
        self.action5_bit.setText(_translate("MainWindow", "5 bit"))
        self.action6_bit.setText(_translate("MainWindow", "6 bit"))
        self.action7_bit.setText(_translate("MainWindow", "7 bit"))
        self.actionHistogram_image.setText(_translate("MainWindow", "Histogram Image"))
        self.actionHistogram_Equalization.setText(_translate("MainWindow", "Histogram Equalization"))
        self.actionFuzzyHistogram_Equalization.setText(_translate("MainWindow", "Fuzzy Histogram Equalization"))
        self.actionFuzzy_HE_RGB.setText(_translate("MainWindow", "Fuzzy HE RGB"))
        self.actionIdentity.setText(_translate("MainWindow", "Identity"))
        self.actionSharpen.setText(_translate("MainWindow", "Sharpen"))
        self.actionUnsharp_Masking.setText(_translate("MainWindow", "Unsharp Masking"))
        self.actionAverage_Filter.setText(_translate("MainWindow", "Average Filter"))
        self.actionLow_Pass_Filter.setText(_translate("MainWindow", "Low Pass Filter"))
        self.actionBandstop_Filter.setText(_translate("MainWindow", "Bandstop Filter"))
        self.actionEdge_Detection_1.setText(_translate("MainWindow", "Edge Detection 1"))
        self.actionEdge_Detection_2.setText(_translate("MainWindow", "Edge Detection 2"))
        self.actionEdge_Detection_3.setText(_translate("MainWindow", "Edge Detection 3"))
        self.actionGaussian_Blur_3x3.setText(_translate("MainWindow", "Gaussian Blur 3x3"))
        self.actionGaussian_Blur_5x5.setText(_translate("MainWindow", "Gaussian Blur 5x5"))
        self.actionPrewitt.setText(_translate("MainWindow", "Prewitt"))
        self.actionCanny.setText(_translate("MainWindow", "Canny"))
        self.actionSobel.setText(_translate("MainWindow", "Sobel"))
        self.actionSquare_3.setText(_translate("MainWindow", "Square 3"))
        self.actionSquare_5.setText(_translate("MainWindow", "Square 5"))
        self.actionCross_3.setText(_translate("MainWindow", "Cross 3"))
        self.actionSquare_4.setText(_translate("MainWindow", "Square 3"))
        self.actionSquare_6.setText(_translate("MainWindow", "Square 5"))
        self.actionCross_4.setText(_translate("MainWindow", "Cross 3"))
        self.actionSquare_9.setText(_translate("MainWindow", "Square 9"))
        self.actionSquare_10.setText(_translate("MainWindow", "Square 9"))

        self.menuExtraction.setTitle(_translate("MainWindow", "Extraction"))
        self.actionRGB.setText(_translate("MainWindow", "RGB"))
        self.actionGLCM.setText(_translate("MainWindow", "GLCM"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())


    
